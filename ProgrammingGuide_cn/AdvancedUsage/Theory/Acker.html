<!DOCTYPE html>
<!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>JStorm 文档 : Acker</title>
    <link rel="shortcut icon" href="/img/favicon.png" type="image/x-icon">
    <link rel="icon" href="/img/favicon.png" type="image/x-icon">

    <!-- Bootstrap -->
    <link href="//cdn.bootcss.com/bootstrap/3.3.4/css/bootstrap.min.css" rel="stylesheet">
    <link rel="stylesheet" href="/css/jstorm.css">
    <link rel="stylesheet" href="/css/syntax.css">
    <link rel="stylesheet" href="/css/codetabs.css">
    
    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
  </head>
  <body>
    
    <!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<!--




-->
    <!-- Top navbar. -->
    <nav class="navbar navbar-default navbar-fixed-top">
      <div class="container">
        <!-- The logo. -->
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <div class="navbar-logo">
            <a href="/"><img alt="jstorm" src="/img/jstorm-logo.png"></a>
          </div>
        </div><!-- /.navbar-header -->

        <!-- The navigation links. -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
          <ul class="nav navbar-nav">
            <!-- Downloads -->
            <li class="hidden-sm "><a href="/Downloads.html">Downloads</a></li>

            <!-- Performance -->
            <li class="hidden-sm "><a href="/Performance_cn">Performance</a></li>

            <!-- QuickStart -->
            <li class="dropdown">
              <a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">QuickStart <span class="caret"></span></a>
              <ul class="dropdown-menu" role="menu">
                
                
                <li class=""><a href="/QuickStart_cn/BasicConception.html">5分钟基础概念(新手第一篇)</a></li>
                
                <li class=""><a href="/QuickStart_cn/Example.html">入门Example</a></li>
                
                <li class=""><a href="/QuickStart_cn/Deploy/index.html">安装部署</a></li>
                
                <li class=""><a href="/QuickStart_cn/Upgrade/index.html">升级</a></li>
                
                <li class=""><a href="/QuickStart_cn/UpgradeFromStorm.html">从Apache Storm升级到JStorm</a></li>
                
                <li class=""><a href="/QuickStart_cn/Compile.html">编译JStorm</a></li>
                
              </ul>
            </li>

            <!-- ProgrammingGuide -->
            <li class="dropdown active">
              <a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">ProgrammingGuide <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  
                  
                  <li class=""><a href="/ProgrammingGuide_cn/DebugLocalApp.html">本地调试</a></li>
                  
                  <li class=""><a href="/ProgrammingGuide_cn/StreamSplitJoin.html">数据流分流合并</a></li>
                  
                  <li class=""><a href="/ProgrammingGuide_cn/Transaction/index.html">事务</a></li>
                  
                  <li class=""><a href="/ProgrammingGuide_cn/Trident/index.html">Trident</a></li>
                  
                  <li class=""><a href="/ProgrammingGuide_cn/AdvancedUsage/index.html">Advanced Usage</a></li>
                  
              </ul>
            </li>

            <!-- Maintenance -->
            <li class="dropdown">
              <a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">运维 <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  
                  
                  <li class=""><a href="/Maintenance_cn/Configuration.html">配置注解</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/ConfigurationAutomacticSync.html">自动同步配置文件</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/Isolation.html">资源隔离</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/JStormMetrics.html">JStorm Metrics</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/HealthCheck.html">Supervisor自检</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/JStorm-on-Yarn.html">JStorm-on-Yarn</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/ClusterHA.html">同城灾备&异地灾备</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/BlobStore.html">BlobStore</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/SupervisorWorker.html">生成worker列表算法</a></li>
                  
                  <li class=""><a href="/Maintenance_cn/DynamicAdjustLog.html">动态调整日志</a></li>
                  
              </ul>
            </li>

            <!-- FAQ -->
            <li class="hidden-sm "><a href="/FAQ_cn/">FAQ</a></li>



            <!-- Community -->
            <li class="dropdown">
              <a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">社区 <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  
                  
                  <li class=""><a href="/Community/Email.html">Email List</a></li>
                  
                  <li class=""><a href="/Community/Committers.html">Committer List</a></li>
                  
                  <li class=""><a href="/Community/Events-Meetups.html">Events and Meetups</a></li>
                  
                  <li class=""><a href="/Community/Issues.html">Track issues</a></li>
                  
                  <li class=""><a href="/Community/JStormUsers.html">JStorm User List</a></li>
                  
              </ul>
            </li>

          </ul>
          <ul class="nav navbar-nav navbar-right">
            <li class="dropdown">
              <a href="" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">Language <span class="caret"></span></a>
                <ul class="dropdown-menu" role="menu">
                  <li class=""><a href="/index.html">English</a></li>
                  <li class=""><a href="/index_cn.html">中文</a></li>

              </ul>
            </li>
          </ul>          
        </div><!-- /.navbar-collapse -->
      </div><!-- /.container -->
    </nav>


    

    <!-- Main content. -->
    <div class="container">
      
      <!--
Licensed to the Apache Software Foundation (ASF) under one
or more contributor license agreements.  See the NOTICE file
distributed with this work for additional information
regarding copyright ownership.  The ASF licenses this file
to you under the Apache License, Version 2.0 (the
"License"); you may not use this file except in compliance
with the License.  You may obtain a copy of the License at

  http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, either express or implied.  See the License for the
specific language governing permissions and limitations
under the License.
-->
<div class="row">


  <!-- Sub Navigation -->
  <div class="col-sm-3">
    <ul id="sub-nav">
      
      
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/index.html" class="">Advanced Usage</a>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/API.html" class="">API介绍</a>
          
          <ul>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/API/Grouping.html" class="">Grouping 介绍</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/API/IBasicBolt.html" class="">IBasicBolt 介绍</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/Theory.html" class="">Theory</a>
          
          <ul>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/Theory/Acker.html" class="active">Acker 原理</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/Plugins.html" class="">Plugins</a>
          
          <ul>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/Plugins/Flux.html" class="">Flux 插件</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/Plugins/Hdfs.html" class="">HDFS 插件</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/UserDefined.html" class="">User-Defined-API</a>
          
          <ul>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/UserDefined/Alarm.html" class="">自定义报错</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/UserDefined/Log.html" class="">自定义日志</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/UserDefined/Metrics.html" class="">自定义监控</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/UserDefined/Scheduler.html" class="">自定义调度</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/DynamicAdjust.html" class="">动态变更</a>
          
          <ul>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/DynamicAdjust/Configuration.html" class="">动态更新配置</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/DynamicAdjust/Metrics.html" class="">动态调整Metrics</a></li>
            
              <li><a href="/ProgrammingGuide_cn/AdvancedUsage/DynamicAdjust/Parallel.html" class="">动态调整并发</a></li>
            
          </ul>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/SQL.html" class="">SQL-on-JStorm</a>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/SubmitTopology.html" class="">API 提交任务</a>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/BackPressure.html" class="">限流控制/反压</a>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/Window.html" class="">Window Framework</a>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/PerformanceTuning.html" class="">性能优化</a>
          
        </li>
      
        
        
        
        <li><a href="/ProgrammingGuide_cn/AdvancedUsage/BlobStore.html" class="">BlobStore</a>
          
        </li>
      
    </ul>
  </div>
  <!-- Main -->
  <div class="col-sm-9">
    <!-- Top anchor -->
    <a href="#top"></a>

    <div class="text">
      <!-- Main heading -->
      <h1>Acker</h1>

      <!-- Content -->
      <ul id="markdown-toc">
  <li><a href="#jstorm-acker详解" id="markdown-toc-jstorm-acker详解">JStorm Acker详解</a>    <ul>
      <li><a href="#acker概述" id="markdown-toc-acker概述">acker概述</a></li>
      <li><a href="#消息流" id="markdown-toc-消息流">消息流</a></li>
      <li><a href="#如何判断消息是否被成功处理" id="markdown-toc-如何判断消息是否被成功处理">如何判断消息是否被成功处理？</a></li>
      <li><a href="#代码分析" id="markdown-toc-代码分析">代码分析</a></li>
      <li><a href="#如何使用acker" id="markdown-toc-如何使用acker">如何使用acker</a></li>
    </ul>
  </li>
</ul>

<h1 id="jstorm-acker详解">JStorm Acker详解</h1>

<hr />

<h3 id="acker概述">acker概述</h3>

<p>JStorm的acker机制，能够保证消息至少被处理一次（at least once）。也就是说，能够保证不丢消息。这里就详细解析一下acker的实现原理。</p>

<h3 id="消息流">消息流</h3>

<p>假设我们有一个简单的topology，结构为spout -&gt; bolt。
spout emit了一条消息，发送至bolt。bolt作为最后一个处理者，没有再向下游emit消息。</p>

<center>
  <img src="/img/programguide/AdvancedUsage/acker_1.png" width="900px" />
</center>

<p>从上图可以看到，所有的ack消息都会发送到acker，acker会根据算法计算从特定spout发射出来的tuple tree是否被完全处理。如果成功处理，则发送__acker_ack消息给spout，否则发送__acker_fail消息给spout。然后spout中可以做相应的逻辑如重发消息等。</p>

<p>在JStorm中，acker是一种bolt，因此它的处理、消息发送跟正常的bolt是一样的。只不过，acker是JStorm框架创建的bolt，用户不能自行创建。如果用户在代码中使用：</p>

<pre><code>Config.setNumAckers(conf, 1);
</code></pre>

<p>就会自动创建并行度为1的acker bolt；如果为0，则就没有acker bolt了。</p>

<h3 id="如何判断消息是否被成功处理">如何判断消息是否被成功处理？</h3>
<p>acker的算法非常巧妙，它利用了数学上的异或操作来实现对整个tuple tree的判断。在一个topology中的一条消息形成的tuple tree中，所有的消息，都会有一个MessageId，它内部其实就是一个map：</p>

<pre><code>Map&lt;Long, Long&gt; _anchorsToIds;
</code></pre>

<p>存储的是anchor和anchor value。而anchor其实就是root_id，它在spout中生成，并且一路透传到所有的bolt中，属于同一个tuple tree中的消息都会有相同的root_id，它可以唯一标识spout发出来的这条消息（以及从下游bolt根据这个tuple衍生发出的消息）。</p>

<p>下面是一个tuple的ack流程：</p>

<ol>
  <li>spout发送消息时，先生成root_id。</li>
  <li>对每一个目标bolt task，生成<code>&lt;root_id, random()&gt;</code>，即为这个root_id对应一个随机数值，然后随着消息本身发送到下游bolt中。假设有2个bolt，生成的随机数对分别为：<code>&lt;root_id, r1&gt;</code>, <code>&lt;root_id, r2&gt;</code>。</li>
  <li>spout向acker发送ack_init消息，它的MessageId = <code>&lt;root_id, r1 ^ r2&gt;</code>（即所有task产生的随机数列表的异或值）。</li>
  <li>bolt收到spout或上游bolt发送过来的tuple之后，首先它会向acker发送ack消息，MessageId即为收到的值。同时，如果bolt下游还有bolt，则跟步骤2类似，会对每一个bolt，生成随机数对，root_id相同，但是值变为<code>当前值 ^ 新生成的随机数</code>。以此类推。</li>
  <li>acker收到消息后，会对root_id下所有的值做异或操作，如果算出来的值为0，表示整个tuple tree被成功处理；否则就会一直等待，直到超时，则tuple tree处理失败。</li>
  <li>acker通知spout消息处理成功或失败。</li>
</ol>

<hr />

<p>我们以一个稍微复杂一点的topology为例，描述一下它的整个过程。
假设我们的topology结构为：
<code>spout -&gt; bolt1/bolt2 -&gt; bolt3</code>
即spout同时向bolt1和bolt2发送消息，它们处理完后，都向bolt3发送消息。bolt3没有后续处理节点。</p>

<center>
  <img src="/img/programguide/AdvancedUsage/acker_2.png" width="900px" />
</center>

<p>1). spout发射一条消息，生成root_id，由于这个值不变，我们就用root_id来标识。
spout -&gt; bolt1的MessageId = <code>&lt;root_id, 1&gt;</code>
spout -&gt; bolt2的MessageId = <code>&lt;root_id, 2&gt;</code>
spout -&gt; acker的MessageId = <code>&lt;root_id, 1^2&gt;</code></p>

<p>2). bolt1收到消息后，生成如下消息：
bolt1 -&gt; bolt3的MessageId = <code>&lt;root_id, 3&gt;</code>
bolt1 -&gt; acker的MessageId = <code>&lt;root_id, 1^3&gt;</code></p>

<p>3). 同样，bolt2收到消息后，生成如下消息：
bolt2 -&gt; bolt3的MessageId = <code>&lt;root_id, 4&gt;</code>
bolt2 -&gt; acker的MessageId = <code>&lt;root_id, 2^4&gt;</code></p>

<p>4). bolt3收到消息后，生成如下消息：
bolt3 -&gt; acker的MessageId = <code>&lt;root_id, 3&gt;</code>
bolt3 -&gt; acker的MessageId = <code>&lt;root_id, 4&gt;</code></p>

<p>5). acker中总共收到以下消息：
<code>&lt;root_id, 1^2&gt;</code>
<code>&lt;root_id, 1^3&gt;</code>
<code>&lt;root_id, 2^4&gt;</code>
<code>&lt;root_id, 3&gt;</code>
<code>&lt;root_id, 4&gt;</code>
所有的值进行异或之后，即为<code>1^2^1^3^2^4^3^4</code> = 0。</p>

<hr />

<h3 id="代码分析">代码分析</h3>
<p>实现ack的代码，主要在这几个类中：<code>SpoutCollector</code>, <code>BoltCollector</code>, <code>Acker</code>。</p>

<p>其中<code>SpoutCollector.sendSpoutMsg方法</code>：</p>

<pre><code class="language-java">    private List&lt;Integer&gt; sendSpoutMsg(String out_stream_id, List&lt;Object&gt; values, Object message_id, Integer out_task_id) {
        final long startTime = System.nanoTime();
        try {
            // 得到目标task id列表
            java.util.List&lt;Integer&gt; out_tasks;
            if (out_task_id != null) {
                out_tasks = sendTargets.get(out_task_id, out_stream_id, values);
            } else {
                out_tasks = sendTargets.get(out_stream_id, values);
            }

            if (out_tasks.size() == 0) {
                // don't need send tuple to other task
                return out_tasks;
            }
            List&lt;Long&gt; ackSeq = new ArrayList&lt;Long&gt;();
            Boolean needAck = (message_id != null) &amp;&amp; (ackerNum &gt; 0);

            // 生成随机的root_id，但是需要确保在当前spout中不能有重复的，不然就不能保证ack的准确性了
            Long root_id = MessageId.generateId(random);
            if (needAck) {
                while (pending.containsKey(root_id)) {
                    root_id = MessageId.generateId(random);
                }
            }
            
            // 遍历所有的目标task，每个task的messageId=&lt;root_id, 随机数值&gt;
            for (Integer t : out_tasks) {
                MessageId msgid;
                if (needAck) {
                    Long as = MessageId.generateId(random);
                    msgid = MessageId.makeRootId(root_id, as);
                    // 添加到ackSeq list中，后面会有用
                    ackSeq.add(as);
                } else {
                    msgid = MessageId.makeUnanchored();
                }

                // 扔到transfer queue中，即进入发送队列
                TupleImplExt tp = new TupleImplExt(topology_context, values, task_id, out_stream_id, msgid);
                tp.setTargetTaskId(t);
                transfer_fn.transfer(tp);
            }

            // ack消息的逻辑在这里面，上面对所有的目标task分别emit消息，但是ack_init消息只需要发送一条。
            if (needAck) {
                TupleInfo info = new TupleInfo();
                info.setStream(out_stream_id);
                info.setValues(values);
                info.setMessageId(message_id);
                info.setTimestamp(System.nanoTime());

                pending.putHead(root_id, info);

                // messageId = &lt;root_id, 所有目标task的messageId随机数值的异或&gt;
                List&lt;Object&gt; ackerTuple = JStormUtils.mk_list((Object) root_id, JStormUtils.bit_xor_vals(ackSeq), task_id);

                // 发送给acker。会根据__acker_init这个stream直接找到task id进行发送。
                UnanchoredSend.send(topology_context, sendTargets, transfer_fn, Acker.ACKER_INIT_STREAM_ID, ackerTuple);

            } else if (message_id != null) {
                // 这里的逻辑，处理没有acker，但是仍然实现了IAckValueSpout接口的情况，需要给这种spout回调ack方法的机会。
                TupleInfo info = new TupleInfo();
                info.setStream(out_stream_id);
                info.setValues(values);
                info.setMessageId(message_id);
                info.setTimestamp(0);

                AckSpoutMsg ack = new AckSpoutMsg(spout, null, info, task_stats, isDebug);
                ack.run();
            }

            return out_tasks;
        } finally {
            long endTime = System.nanoTime();
            emitTotalTimer.update((endTime - startTime) / TimeUtils.NS_PER_US);
        }
    }
</code></pre>

<p>再来看一下<code>BoltCollector</code>类的逻辑，通常来说bolt是先execute（先emit），再执行ack方法。因此先看boltEmit方法：</p>

<pre><code class="language-java">    private List&lt;Integer&gt; boltEmit(String out_stream_id, Collection&lt;Tuple&gt; anchors, List&lt;Object&gt; values, Integer out_task_id) {
        final long start = System.nanoTime();
        try {
            // 一样地获取所有目标task列表
            java.util.List&lt;Integer&gt; out_tasks;
            if (out_task_id != null) {
                out_tasks = sendTargets.get(out_task_id, out_stream_id, values);
            } else {
                out_tasks = sendTargets.get(out_stream_id, values);
            }

            // 遍历所有目标task，每一个目标task的message id= &lt;root_id, edge_id&gt;，其中edge_id是在这个bolt里新生成的随机数
            for (Integer t : out_tasks) {
                Map&lt;Long, Long&gt; anchors_to_ids = new HashMap&lt;Long, Long&gt;();
                if (anchors != null) {
                    // 在一般的情况下anchors的size=1，见BasicOutputCollector类，即为当前收到的inputTuple。
                    for (Tuple a : anchors) {
                        Long edge_id = MessageId.generateId(random);
                        long now = System.currentTimeMillis();
                        // 这里是提前删除可能的超时tuple
                        if (now - lastRotate &gt; rotateTime) {
                            pending_acks.rotate();
                            lastRotate = now;
                        }
                        // 这里会将&lt;inputTuple, edge_id&gt;放入pending_acks
                        put_xor(pending_acks, a, edge_id);
                        // 这里将每一对&lt;root_id, edge_id&gt;放入anchors_to_ids（一般情况下也只有一对），由于anchors_to_ids是一个空map，因此put_xor里面，相当于拿root_id对应的值^0 = root_id的值
                        for (Long root_id : a.getMessageId().getAnchorsToIds().keySet()) {
                            put_xor(anchors_to_ids, root_id, edge_id);
                        }
                    }
                }
                
                // 往目标bolt发送消息
                MessageId msgid = MessageId.makeId(anchors_to_ids);
                TupleImplExt tupleExt = new TupleImplExt(topologyContext, values, task_id, out_stream_id, msgid);
                tupleExt.setTargetTaskId(t);
                taskTransfer.transfer(tupleExt);
            }
            return out_tasks;
        } catch (Exception e) {
            LOG.error("bolt emit", e);
        } finally {
            long end = System.nanoTime();
            timer.update((end - start) / TimeUtils.NS_PER_US);
        }
        return new ArrayList&lt;Integer&gt;();
    }
</code></pre>

<p>emit完之后，再来看ack的逻辑：</p>

<pre><code>    public void ack(Tuple input) {
        if (ackerNum &gt; 0) {
            Long ack_val = 0L;
            // 这里取出boltEmit放入的对象：&lt;inputTuple, edge_id&gt;
            Object pend_val = pending_acks.remove(input);
            if (pend_val != null) {
                // ack_val = edge_id
                ack_val = (Long) (pend_val);
            }

            // 发送ack消息，messageId = &lt;root_id, inputTuple的随机数 ^ edge_id&gt;
            for (Entry&lt;Long, Long&gt; e : input.getMessageId().getAnchorsToIds().entrySet()) {
                UnanchoredSend.send(topologyContext, sendTargets, taskTransfer, Acker.ACKER_ACK_STREAM_ID,
                        JStormUtils.mk_list((Object) e.getKey(), JStormUtils.bit_xor(e.getValue(), ack_val)));
            }
        }

        Long startTime = (Long) tuple_start_times.remove(input);
        if (startTime != null) {
        	Long endTime = System.nanoTime();
        	long latency = (endTime - startTime)/TimeUtils.NS_PER_US;
        	long lifeCycle = (System.currentTimeMillis() - ((TupleExt) input).getCreationTimeStamp()) * TimeUtils.NS_PER_US;
        	
            task_stats.bolt_acked_tuple(input.getSourceComponent(), input.getSourceStreamId(), latency, lifeCycle);
        }
    }
</code></pre>

<p>最后就是acker了，这个逻辑比较简单：</p>

<pre><code class="language-java">    public void execute(Tuple input) {
        Object id = input.getValue(0);
        AckObject curr = pending.get(id);
        String stream_id = input.getSourceStreamId();
        // __acker_init消息，由spout发送，直接放入pending map中
        if (Acker.ACKER_INIT_STREAM_ID.equals(stream_id)) {
            if (curr == null) {
                curr = new AckObject();

                curr.val = input.getLong(1);
                curr.spout_task = input.getInteger(2);

                pending.put(id, curr);
            } else {
                // bolt's ack first come
                curr.update_ack(input.getValue(1));
                curr.spout_task = input.getInteger(2);
            }

        } else if (Acker.ACKER_ACK_STREAM_ID.equals(stream_id)) {
            // __ack_ack消息
            if (curr != null) {
                curr.update_ack(input.getValue(1));
            } else {
                // two case
                // one is timeout
                // the other is bolt's ack first come
                curr = new AckObject();
                curr.val = input.getLong(1);
                pending.put(id, curr);
            }
        } else if (Acker.ACKER_FAIL_STREAM_ID.equals(stream_id)) {
            // 也有可能直接fail了
            if (curr == null) {
                // do nothing
                // already timeout, should go fail
                return;
            }
            curr.failed = true;
        } else {
            LOG.info("Unknow source stream");
            return;
        }

        // 告诉spout这个消息ack/fail了
        Integer task = curr.spout_task;
        if (task != null) {
            if (curr.val == 0) {
                pending.remove(id);
                List values = JStormUtils.mk_list(id);
                collector.emitDirect(task, Acker.ACKER_ACK_STREAM_ID, values);
            } else {
                if (curr.failed) {
                    pending.remove(id);
                    List values = JStormUtils.mk_list(id);
                    collector.emitDirect(task, Acker.ACKER_FAIL_STREAM_ID, values);
                }
            }
        } else {

        }

        // 这里只是更新metrics
        // add this operation to update acker's ACK statics
        collector.ack(input);

        long now = System.currentTimeMillis();
        if (now - lastRotate &gt; rotateTime) {
            lastRotate = now;
            Map&lt;Object, AckObject&gt; tmp = pending.rotate();
            LOG.info("Acker's timeout item size:{}", tmp.size());
        }
    }
</code></pre>

<h3 id="如何使用acker">如何使用acker</h3>

<ol>
  <li>设置acker的并发度要&gt;0;</li>
  <li>spout发送消息时，使用的接口List<Integer> emit(List<object> tuple, Object messageId)；其中messageId由用户指定生成，用户消息处理成功或者失败后，用于对public void ack(Object messageId) 和public void fail(Object messageId) 接口的回调；</object></Integer></li>
  <li>如果spout同时从IAckValueSpout和IFailValueSpout派生，那么要求实现void fail(Object messageId, List<object> values)和void ack(Object messageId, List<object> values);这两接口除了会返回messageId，还会返回每一条消息；</object></object></li>
  <li>bolt一般从如果从IRichBolt派生，发送消息到下游时要注意以下两种不同类型的接口：
    <pre><code> public List&lt;Integer&gt; emit(Tuple anchor, List&lt;Object&gt; tuple); //anchor 代表当前bolt接收到的消息， tuple代表发送到下游的消息
 public List&lt;Integer&gt; emit(List&lt;Object&gt; tuple);
 //如果对即将发送的消息不打算acker的话，可以直接用第二种接口；如果需要对即将发送的下游的消息要进行acker的话，emit的时候需要携带anchor
</code></pre>
  </li>
  <li>如果bolt接收到的消息是需要被acker的话，记得在execute里头别忘了执行_collector.ack(tuple)操作；例子如下
    <pre><code> @Override
 public void execute(Tuple tuple) {
     _collector.emit(tuple, new Values(tuple.getString(0)));
     _collector.ack(tuple);
 }
</code></pre>
  </li>
  <li>
    <p>对于从IRichBolt派生的的bolt来说是不是很麻烦，即要求采样合适的emit接口，还要求主动执行acker操作，那么好消息来了如果当前bolt是从IBasicBolt派生的话，内部都会帮你执行这些操作，你只管调用emit(List<object> tuple)发送消息即可；</object></p>
  </li>
  <li>例子如下</li>
</ol>

<pre><code>public class PairCount implements IBasicBolt {
    private static final long serialVersionUID = 7346295981904929419L;

    public static final Logger LOG = LoggerFactory.getLogger(PairCount.class);

	private AtomicLong  sum = new AtomicLong(0);
	
	private TpsCounter          tpsCounter;

	public void prepare(Map conf, TopologyContext context) {
	    tpsCounter = new TpsCounter(context.getThisComponentId() + 
                ":" + context.getThisTaskId());
		
		LOG.info("Successfully do parepare " + context.getThisComponentId());
	}

	public void execute(Tuple tuple, BasicOutputCollector collector) {
	    tpsCounter.count();
	    
		Long tupleId = tuple.getLong(0);
		Pair pair = (Pair)tuple.getValue(1);
        
        sum.addAndGet(pair.getValue());
        
        // 如果需要ack，只需要这么做：
        collector.emit(new Values(tupleId, pair)); 
	}

	public void cleanup() {
	    tpsCounter.cleanup();
		LOG.info("Total receive value :" + sum);
	}

	public void declareOutputFields(OutputFieldsDeclarer declarer) {
		declarer.declare(new Fields("ID", "PAIR"));
	}

	public Map&lt;String, Object&gt; getComponentConfiguration() {
	    // TODO Auto-generated method stub
	    return null;
	}
}
</code></pre>
      
      <div class="footer">
      Google Groups: <a target="_blank" href="https://groups.google.com/forum/#!forum/jstorm-user">jstorm-user</a>, QQ Groups: 228374502
      </p>
 
      发现错误？想参与编辑？
      <a href="https://github.com/alibaba/jstorm/edit/master/docs/jstorm-doc/ProgrammingGuide_cn/AdvancedUsage/Theory/Acker.md" target="_blank">
        在 Github 上编辑此页！
      </a>
  </div>
    </div>
  </div>

  
</div>

    </div><!-- /.container -->

    <!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
    <script src="//cdn.bootcss.com/jquery/1.11.2/jquery.min.js"></script>
    <!-- Include all compiled plugins (below), or include individual files as needed -->
    <script src="//cdn.bootcss.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
    <script src="//cdn.bootcss.com/anchor-js/3.1.0/anchor.min.js"></script>
    <script src="/js/jstorm.js"></script>

    <!-- Google Analytics -->
    <!-- script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

      ga('create', 'UA-52545728-1', 'auto');
      ga('send', 'pageview');
    </script -->

    <!-- Baidu Analytics -->
    <script>
      var _hmt = _hmt || [];
      (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?835985ad7943d8c24bc3c1f155b7d4a2";
        var s = document.getElementsByTagName("script")[0]; 
        s.parentNode.insertBefore(hm, s);
      })();
    </script>


    <!-- Disqus -->
    <!--
     -->
  </body>
</html>
