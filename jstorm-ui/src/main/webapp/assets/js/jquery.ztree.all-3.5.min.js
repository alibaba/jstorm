/*
 * JQuery zTree core 3.5
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2012-11-20
 */
(function (k) {
    var E, F, G, H, I, J, r = {}, K = {}, s = {}, L = {treeId: "", treeObj: null, view: {addDiyDom: null, autoCancelSelected: !0, dblClickExpand: !0, expandSpeed: "fast", fontCss: {}, nameIsHTML: !1, selectedMulti: !0, showIcon: !0, showLine: !0, showTitle: !0}, data: {key: {children: "children", name: "name", title: "", url: "url"}, simpleData: {enable: !1, idKey: "id", pIdKey: "pId", rootPId: null}, keep: {parent: !1, leaf: !1}}, async: {enable: !1, contentType: "application/x-www-form-urlencoded", type: "post", dataType: "text", url: "", autoParam: [], otherParam: [],
            dataFilter: null}, callback: {beforeAsync: null, beforeClick: null, beforeDblClick: null, beforeRightClick: null, beforeMouseDown: null, beforeMouseUp: null, beforeExpand: null, beforeCollapse: null, beforeRemove: null, onAsyncError: null, onAsyncSuccess: null, onNodeCreated: null, onClick: null, onDblClick: null, onRightClick: null, onMouseDown: null, onMouseUp: null, onExpand: null, onCollapse: null, onRemove: null}}, t = [function (b) {
            var a = b.treeObj, c = e.event;
            a.bind(c.NODECREATED, function (a, c, h) {
                j.apply(b.callback.onNodeCreated, [a, c, h])
            });
            a.bind(c.CLICK, function (a, c, h, l, g) {
                j.apply(b.callback.onClick, [c, h, l, g])
            });
            a.bind(c.EXPAND, function (a, c, h) {
                j.apply(b.callback.onExpand, [a, c, h])
            });
            a.bind(c.COLLAPSE, function (a, c, h) {
                j.apply(b.callback.onCollapse, [a, c, h])
            });
            a.bind(c.ASYNC_SUCCESS, function (a, c, h, l) {
                j.apply(b.callback.onAsyncSuccess, [a, c, h, l])
            });
            a.bind(c.ASYNC_ERROR, function (a, c, h, l, g, e) {
                j.apply(b.callback.onAsyncError, [a, c, h, l, g, e])
            })
        }], u = [function (b) {
            var a = e.event;
            b.treeObj.unbind(a.NODECREATED).unbind(a.CLICK).unbind(a.EXPAND).unbind(a.COLLAPSE).unbind(a.ASYNC_SUCCESS).unbind(a.ASYNC_ERROR)
        }],
        v = [function (b) {
            var a = g.getCache(b);
            a || (a = {}, g.setCache(b, a));
            a.nodes = [];
            a.doms = []
        }], w = [function (b, a, c, d, f, h) {
            if (c) {
                var l = g.getRoot(b), e = b.data.key.children;
                c.level = a;
                c.tId = b.treeId + "_" + ++l.zId;
                c.parentTId = d ? d.tId : null;
                if (c[e] && c[e].length > 0) {
                    if (typeof c.open == "string")c.open = j.eqs(c.open, "true");
                    c.open = !!c.open;
                    c.isParent = !0;
                    c.zAsync = !0
                } else {
                    c.open = !1;
                    if (typeof c.isParent == "string")c.isParent = j.eqs(c.isParent, "true");
                    c.isParent = !!c.isParent;
                    c.zAsync = !c.isParent
                }
                c.isFirstNode = f;
                c.isLastNode = h;
                c.getParentNode =
                    function () {
                        return g.getNodeCache(b, c.parentTId)
                    };
                c.getPreNode = function () {
                    return g.getPreNode(b, c)
                };
                c.getNextNode = function () {
                    return g.getNextNode(b, c)
                };
                c.isAjaxing = !1;
                g.fixPIdKeyValue(b, c)
            }
        }], x = [function (b) {
            var a = b.target, c = g.getSetting(b.data.treeId), d = "", f = null, h = "", l = "", i = null, n = null, q = null;
            if (j.eqs(b.type, "mousedown"))l = "mousedown"; else if (j.eqs(b.type, "mouseup"))l = "mouseup"; else if (j.eqs(b.type, "contextmenu"))l = "contextmenu"; else if (j.eqs(b.type, "click"))if (j.eqs(a.tagName, "span") && a.getAttribute("treeNode" +
                e.id.SWITCH) !== null)d = (k(a).parent("li").get(0) || k(a).parentsUntil("li").parent().get(0)).id, h = "switchNode"; else {
                if (q = j.getMDom(c, a, [
                    {tagName: "a", attrName: "treeNode" + e.id.A}
                ]))d = (k(q).parent("li").get(0) || k(q).parentsUntil("li").parent().get(0)).id, h = "clickNode"
            } else if (j.eqs(b.type, "dblclick") && (l = "dblclick", q = j.getMDom(c, a, [
                {tagName: "a", attrName: "treeNode" + e.id.A}
            ])))d = (k(q).parent("li").get(0) || k(q).parentsUntil("li").parent().get(0)).id, h = "switchNode";
            if (l.length > 0 && d.length == 0 && (q = j.getMDom(c,
                a, [
                    {tagName: "a", attrName: "treeNode" + e.id.A}
                ])))d = (k(q).parent("li").get(0) || k(q).parentsUntil("li").parent().get(0)).id;
            if (d.length > 0)switch (f = g.getNodeCache(c, d), h) {
                case "switchNode":
                    f.isParent ? j.eqs(b.type, "click") || j.eqs(b.type, "dblclick") && j.apply(c.view.dblClickExpand, [c.treeId, f], c.view.dblClickExpand) ? i = E : h = "" : h = "";
                    break;
                case "clickNode":
                    i = F
            }
            switch (l) {
                case "mousedown":
                    n = G;
                    break;
                case "mouseup":
                    n = H;
                    break;
                case "dblclick":
                    n = I;
                    break;
                case "contextmenu":
                    n = J
            }
            return{stop: !1, node: f, nodeEventType: h, nodeEventCallback: i,
                treeEventType: l, treeEventCallback: n}
        }], y = [function (b) {
            var a = g.getRoot(b);
            a || (a = {}, g.setRoot(b, a));
            a[b.data.key.children] = [];
            a.expandTriggerFlag = !1;
            a.curSelectedList = [];
            a.noSelection = !0;
            a.createdNodes = [];
            a.zId = 0;
            a._ver = (new Date).getTime()
        }], z = [], A = [], B = [], C = [], D = [], g = {addNodeCache: function (b, a) {
            g.getCache(b).nodes[g.getNodeCacheId(a.tId)] = a
        }, getNodeCacheId: function (b) {
            return b.substring(b.lastIndexOf("_") + 1)
        }, addAfterA: function (b) {
            A.push(b)
        }, addBeforeA: function (b) {
            z.push(b)
        }, addInnerAfterA: function (b) {
            C.push(b)
        },
            addInnerBeforeA: function (b) {
                B.push(b)
            }, addInitBind: function (b) {
                t.push(b)
            }, addInitUnBind: function (b) {
                u.push(b)
            }, addInitCache: function (b) {
                v.push(b)
            }, addInitNode: function (b) {
                w.push(b)
            }, addInitProxy: function (b) {
                x.push(b)
            }, addInitRoot: function (b) {
                y.push(b)
            }, addNodesData: function (b, a, c) {
                var d = b.data.key.children;
                a[d] || (a[d] = []);
                if (a[d].length > 0)a[d][a[d].length - 1].isLastNode = !1, i.setNodeLineIcos(b, a[d][a[d].length - 1]);
                a.isParent = !0;
                a[d] = a[d].concat(c)
            }, addSelectedNode: function (b, a) {
                var c = g.getRoot(b);
                g.isSelectedNode(b,
                    a) || c.curSelectedList.push(a)
            }, addCreatedNode: function (b, a) {
                (b.callback.onNodeCreated || b.view.addDiyDom) && g.getRoot(b).createdNodes.push(a)
            }, addZTreeTools: function (b) {
                D.push(b)
            }, exSetting: function (b) {
                k.extend(!0, L, b)
            }, fixPIdKeyValue: function (b, a) {
                b.data.simpleData.enable && (a[b.data.simpleData.pIdKey] = a.parentTId ? a.getParentNode()[b.data.simpleData.idKey] : b.data.simpleData.rootPId)
            }, getAfterA: function (b, a, c) {
                for (var d = 0, f = A.length; d < f; d++)A[d].apply(this, arguments)
            }, getBeforeA: function (b, a, c) {
                for (var d =
                    0, f = z.length; d < f; d++)z[d].apply(this, arguments)
            }, getInnerAfterA: function (b, a, c) {
                for (var d = 0, f = C.length; d < f; d++)C[d].apply(this, arguments)
            }, getInnerBeforeA: function (b, a, c) {
                for (var d = 0, f = B.length; d < f; d++)B[d].apply(this, arguments)
            }, getCache: function (b) {
                return s[b.treeId]
            }, getNextNode: function (b, a) {
                if (!a)return null;
                for (var c = b.data.key.children, d = a.parentTId ? a.getParentNode() : g.getRoot(b), f = 0, h = d[c].length - 1; f <= h; f++)if (d[c][f] === a)return f == h ? null : d[c][f + 1];
                return null
            }, getNodeByParam: function (b, a, c, d) {
                if (!a || !c)return null;
                for (var f = b.data.key.children, h = 0, l = a.length; h < l; h++) {
                    if (a[h][c] == d)return a[h];
                    var e = g.getNodeByParam(b, a[h][f], c, d);
                    if (e)return e
                }
                return null
            }, getNodeCache: function (b, a) {
                if (!a)return null;
                var c = s[b.treeId].nodes[g.getNodeCacheId(a)];
                return c ? c : null
            }, getNodeName: function (b, a) {
                return"" + a[b.data.key.name]
            }, getNodeTitle: function (b, a) {
                return"" + a[b.data.key.title === "" ? b.data.key.name : b.data.key.title]
            }, getNodes: function (b) {
                return g.getRoot(b)[b.data.key.children]
            }, getNodesByParam: function (b, a, c, d) {
                if (!a || !c)return[];
                for (var f = b.data.key.children, h = [], l = 0, e = a.length; l < e; l++)a[l][c] == d && h.push(a[l]), h = h.concat(g.getNodesByParam(b, a[l][f], c, d));
                return h
            }, getNodesByParamFuzzy: function (b, a, c, d) {
                if (!a || !c)return[];
                for (var f = b.data.key.children, h = [], l = 0, e = a.length; l < e; l++)typeof a[l][c] == "string" && a[l][c].indexOf(d) > -1 && h.push(a[l]), h = h.concat(g.getNodesByParamFuzzy(b, a[l][f], c, d));
                return h
            }, getNodesByFilter: function (b, a, c, d, f) {
                if (!a)return d ? null : [];
                for (var h = b.data.key.children, l = d ? null :
                    [], e = 0, i = a.length; e < i; e++) {
                    if (j.apply(c, [a[e], f], !1)) {
                        if (d)return a[e];
                        l.push(a[e])
                    }
                    var k = g.getNodesByFilter(b, a[e][h], c, d, f);
                    if (d && k)return k;
                    l = d ? k : l.concat(k)
                }
                return l
            }, getPreNode: function (b, a) {
                if (!a)return null;
                for (var c = b.data.key.children, d = a.parentTId ? a.getParentNode() : g.getRoot(b), f = 0, h = d[c].length; f < h; f++)if (d[c][f] === a)return f == 0 ? null : d[c][f - 1];
                return null
            }, getRoot: function (b) {
                return b ? K[b.treeId] : null
            }, getSetting: function (b) {
                return r[b]
            }, getSettings: function () {
                return r
            }, getZTreeTools: function (b) {
                return(b =
                    this.getRoot(this.getSetting(b))) ? b.treeTools : null
            }, initCache: function (b) {
                for (var a = 0, c = v.length; a < c; a++)v[a].apply(this, arguments)
            }, initNode: function (b, a, c, d, f, h) {
                for (var l = 0, e = w.length; l < e; l++)w[l].apply(this, arguments)
            }, initRoot: function (b) {
                for (var a = 0, c = y.length; a < c; a++)y[a].apply(this, arguments)
            }, isSelectedNode: function (b, a) {
                for (var c = g.getRoot(b), d = 0, f = c.curSelectedList.length; d < f; d++)if (a === c.curSelectedList[d])return!0;
                return!1
            }, removeNodeCache: function (b, a) {
                var c = b.data.key.children;
                if (a[c])for (var d =
                    0, f = a[c].length; d < f; d++)arguments.callee(b, a[c][d]);
                g.getCache(b).nodes[g.getNodeCacheId(a.tId)] = null
            }, removeSelectedNode: function (b, a) {
                for (var c = g.getRoot(b), d = 0, f = c.curSelectedList.length; d < f; d++)if (a === c.curSelectedList[d] || !g.getNodeCache(b, c.curSelectedList[d].tId))c.curSelectedList.splice(d, 1), d--, f--
            }, setCache: function (b, a) {
                s[b.treeId] = a
            }, setRoot: function (b, a) {
                K[b.treeId] = a
            }, setZTreeTools: function (b, a) {
                for (var c = 0, d = D.length; c < d; c++)D[c].apply(this, arguments)
            }, transformToArrayFormat: function (b, a) {
                if (!a)return[];
                var c = b.data.key.children, d = [];
                if (j.isArray(a))for (var f = 0, h = a.length; f < h; f++)d.push(a[f]), a[f][c] && (d = d.concat(g.transformToArrayFormat(b, a[f][c]))); else d.push(a), a[c] && (d = d.concat(g.transformToArrayFormat(b, a[c])));
                return d
            }, transformTozTreeFormat: function (b, a) {
                var c, d, f = b.data.simpleData.idKey, h = b.data.simpleData.pIdKey, l = b.data.key.children;
                if (!f || f == "" || !a)return[];
                if (j.isArray(a)) {
                    var e = [], g = [];
                    for (c = 0, d = a.length; c < d; c++)g[a[c][f]] = a[c];
                    for (c = 0, d = a.length; c < d; c++)g[a[c][h]] &&
                        a[c][f] != a[c][h] ? (g[a[c][h]][l] || (g[a[c][h]][l] = []), g[a[c][h]][l].push(a[c])) : e.push(a[c]);
                    return e
                } else return[a]
            }}, m = {bindEvent: function (b) {
            for (var a = 0, c = t.length; a < c; a++)t[a].apply(this, arguments)
        }, unbindEvent: function (b) {
            for (var a = 0, c = u.length; a < c; a++)u[a].apply(this, arguments)
        }, bindTree: function (b) {
            var a = {treeId: b.treeId}, b = b.treeObj;
            b.bind("click", a, m.proxy);
            b.bind("dblclick", a, m.proxy);
            b.bind("mouseover", a, m.proxy);
            b.bind("mouseout", a, m.proxy);
            b.bind("mousedown", a, m.proxy);
            b.bind("mouseup",
                a, m.proxy);
            b.bind("contextmenu", a, m.proxy)
        }, unbindTree: function (b) {
            b.treeObj.unbind("click", m.proxy).unbind("dblclick", m.proxy).unbind("mouseover", m.proxy).unbind("mouseout", m.proxy).unbind("mousedown", m.proxy).unbind("mouseup", m.proxy).unbind("contextmenu", m.proxy)
        }, doProxy: function (b) {
            for (var a = [], c = 0, d = x.length; c < d; c++) {
                var f = x[c].apply(this, arguments);
                a.push(f);
                if (f.stop)break
            }
            return a
        }, proxy: function (b) {
            var a = g.getSetting(b.data.treeId);
            if (!j.uCanDo(a, b))return!0;
            for (var c = m.doProxy(b), d = !0,
                     f = !1, h = 0, e = c.length; h < e; h++) {
                var i = c[h];
                i.nodeEventCallback && (f = !0, d = i.nodeEventCallback.apply(i, [b, i.node]) && d);
                i.treeEventCallback && (f = !0, d = i.treeEventCallback.apply(i, [b, i.node]) && d)
            }
            try {
                f && k("input:focus").length == 0 && j.noSel(a)
            } catch (n) {
            }
            return d
        }};
    E = function (b, a) {
        var c = g.getSetting(b.data.treeId);
        if (a.open) {
            if (j.apply(c.callback.beforeCollapse, [c.treeId, a], !0) == !1)return!0
        } else if (j.apply(c.callback.beforeExpand, [c.treeId, a], !0) == !1)return!0;
        g.getRoot(c).expandTriggerFlag = !0;
        i.switchNode(c, a);
        return!0
    };
    F = function (b, a) {
        var c = g.getSetting(b.data.treeId), d = c.view.autoCancelSelected && b.ctrlKey && g.isSelectedNode(c, a) ? 0 : c.view.autoCancelSelected && b.ctrlKey && c.view.selectedMulti ? 2 : 1;
        if (j.apply(c.callback.beforeClick, [c.treeId, a, d], !0) == !1)return!0;
        d === 0 ? i.cancelPreSelectedNode(c, a) : i.selectNode(c, a, d === 2);
        c.treeObj.trigger(e.event.CLICK, [b, c.treeId, a, d]);
        return!0
    };
    G = function (b, a) {
        var c = g.getSetting(b.data.treeId);
        j.apply(c.callback.beforeMouseDown, [c.treeId, a], !0) && j.apply(c.callback.onMouseDown,
            [b, c.treeId, a]);
        return!0
    };
    H = function (b, a) {
        var c = g.getSetting(b.data.treeId);
        j.apply(c.callback.beforeMouseUp, [c.treeId, a], !0) && j.apply(c.callback.onMouseUp, [b, c.treeId, a]);
        return!0
    };
    I = function (b, a) {
        var c = g.getSetting(b.data.treeId);
        j.apply(c.callback.beforeDblClick, [c.treeId, a], !0) && j.apply(c.callback.onDblClick, [b, c.treeId, a]);
        return!0
    };
    J = function (b, a) {
        var c = g.getSetting(b.data.treeId);
        j.apply(c.callback.beforeRightClick, [c.treeId, a], !0) && j.apply(c.callback.onRightClick, [b, c.treeId, a]);
        return typeof c.callback.onRightClick !=
            "function"
    };
    var j = {apply: function (b, a, c) {
        return typeof b == "function" ? b.apply(M, a ? a : []) : c
    }, canAsync: function (b, a) {
        var c = b.data.key.children;
        return b.async.enable && a && a.isParent && !(a.zAsync || a[c] && a[c].length > 0)
    }, clone: function (b) {
        if (b === null)return null;
        var a = b.constructor === Array ? [] : {}, c;
        for (c in b)b.hasOwnProperty(c) && (a[c] = typeof b[c] === "object" ? arguments.callee(b[c]) : b[c]);
        return a
    }, eqs: function (b, a) {
        return b.toLowerCase() === a.toLowerCase()
    }, isArray: function (b) {
        return Object.prototype.toString.apply(b) ===
            "[object Array]"
    }, getMDom: function (b, a, c) {
        if (!a)return null;
        for (; a && a.id !== b.treeId;) {
            for (var d = 0, f = c.length; a.tagName && d < f; d++)if (j.eqs(a.tagName, c[d].tagName) && a.getAttribute(c[d].attrName) !== null)return a;
            a = a.parentNode
        }
        return null
    }, noSel: function (b) {
        if (g.getRoot(b).noSelection)try {
            window.getSelection ? window.getSelection().removeAllRanges() : document.selection.empty()
        } catch (a) {
        }
    }, uCanDo: function () {
        return!0
    }}, i = {addNodes: function (b, a, c, d) {
        if (!b.data.keep.leaf || !a || a.isParent)if (j.isArray(c) || (c =
            [c]), b.data.simpleData.enable && (c = g.transformTozTreeFormat(b, c)), a) {
            var f = k("#" + a.tId + e.id.SWITCH), h = k("#" + a.tId + e.id.ICON), l = k("#" + a.tId + e.id.UL);
            if (!a.open)i.replaceSwitchClass(a, f, e.folder.CLOSE), i.replaceIcoClass(a, h, e.folder.CLOSE), a.open = !1, l.css({display: "none"});
            g.addNodesData(b, a, c);
            i.createNodes(b, a.level + 1, c, a);
            d || i.expandCollapseParentNode(b, a, !0)
        } else g.addNodesData(b, g.getRoot(b), c), i.createNodes(b, 0, c, null)
    }, appendNodes: function (b, a, c, d, f, h) {
        if (!c)return[];
        for (var e = [], j = b.data.key.children,
                 k = 0, q = c.length; k < q; k++) {
            var o = c[k];
            if (f) {
                var m = (d ? d : g.getRoot(b))[j].length == c.length && k == 0;
                g.initNode(b, a, o, d, m, k == c.length - 1, h);
                g.addNodeCache(b, o)
            }
            m = [];
            o[j] && o[j].length > 0 && (m = i.appendNodes(b, a + 1, o[j], o, f, h && o.open));
            h && (i.makeDOMNodeMainBefore(e, b, o), i.makeDOMNodeLine(e, b, o), g.getBeforeA(b, o, e), i.makeDOMNodeNameBefore(e, b, o), g.getInnerBeforeA(b, o, e), i.makeDOMNodeIcon(e, b, o), g.getInnerAfterA(b, o, e), i.makeDOMNodeNameAfter(e, b, o), g.getAfterA(b, o, e), o.isParent && o.open && i.makeUlHtml(b, o, e, m.join("")),
                i.makeDOMNodeMainAfter(e, b, o), g.addCreatedNode(b, o))
        }
        return e
    }, appendParentULDom: function (b, a) {
        var c = [], d = k("#" + a.tId), f = k("#" + a.tId + e.id.UL), h = i.appendNodes(b, a.level + 1, a[b.data.key.children], a, !1, !0);
        i.makeUlHtml(b, a, c, h.join(""));
        !d.get(0) && a.parentTId && (i.appendParentULDom(b, a.getParentNode()), d = k("#" + a.tId));
        f.get(0) && f.remove();
        d.append(c.join(""))
    }, asyncNode: function (b, a, c, d) {
        var f, h;
        if (a && !a.isParent)return j.apply(d), !1; else if (a && a.isAjaxing)return!1; else if (j.apply(b.callback.beforeAsync,
            [b.treeId, a], !0) == !1)return j.apply(d), !1;
        if (a)a.isAjaxing = !0, k("#" + a.tId + e.id.ICON).attr({style: "", "class": "button ico_loading"});
        var l = b.async.contentType == "application/json", p = l ? "{" : "", n = "";
        for (f = 0, h = b.async.autoParam.length; a && f < h; f++) {
            var m = b.async.autoParam[f].split("="), o = m;
            m.length > 1 && (o = m[1], m = m[0]);
            l ? (n = typeof a[m] == "string" ? '"' : "", p += '"' + o + ('":' + n + a[m]).replace(/'/g, "\\'") + n + ",") : p += o + ("=" + a[m]).replace(/&/g, "%26") + "&"
        }
        if (j.isArray(b.async.otherParam))for (f = 0, h = b.async.otherParam.length; f <
            h; f += 2)l ? (n = typeof b.async.otherParam[f + 1] == "string" ? '"' : "", p += '"' + b.async.otherParam[f] + ('":' + n + b.async.otherParam[f + 1]).replace(/'/g, "\\'") + n + ",") : p += b.async.otherParam[f] + ("=" + b.async.otherParam[f + 1]).replace(/&/g, "%26") + "&"; else for (var r in b.async.otherParam)l ? (n = typeof b.async.otherParam[r] == "string" ? '"' : "", p += '"' + r + ('":' + n + b.async.otherParam[r]).replace(/'/g, "\\'") + n + ",") : p += r + ("=" + b.async.otherParam[r]).replace(/&/g, "%26") + "&";
        p.length > 1 && (p = p.substring(0, p.length - 1));
        l && (p += "}");
        var s = g.getRoot(b)._ver;
        k.ajax({contentType: b.async.contentType, type: b.async.type, url: j.apply(b.async.url, [b.treeId, a], b.async.url), data: p, dataType: b.async.dataType, success: function (f) {
            if (s == g.getRoot(b)._ver) {
                var h = [];
                try {
                    h = !f || f.length == 0 ? [] : typeof f == "string" ? eval("(" + f + ")") : f
                } catch (l) {
                    h = f
                }
                if (a)a.isAjaxing = null, a.zAsync = !0;
                i.setNodeLineIcos(b, a);
                h && h !== "" ? (h = j.apply(b.async.dataFilter, [b.treeId, a, h], h), i.addNodes(b, a, h ? j.clone(h) : [], !!c)) : i.addNodes(b, a, [], !!c);
                b.treeObj.trigger(e.event.ASYNC_SUCCESS, [b.treeId, a, f]);
                j.apply(d)
            }
        }, error: function (c, d, f) {
            if (s == g.getRoot(b)._ver) {
                if (a)a.isAjaxing = null;
                i.setNodeLineIcos(b, a);
                b.treeObj.trigger(e.event.ASYNC_ERROR, [b.treeId, a, c, d, f])
            }
        }});
        return!0
    }, cancelPreSelectedNode: function (b, a) {
        for (var c = g.getRoot(b).curSelectedList, d = c.length - 1; d >= 0; d--)if (!a || a === c[d])if (k("#" + c[d].tId + e.id.A).removeClass(e.node.CURSELECTED), a) {
            g.removeSelectedNode(b, a);
            break
        }
        if (!a)g.getRoot(b).curSelectedList = []
    }, createNodeCallback: function (b) {
        if (b.callback.onNodeCreated || b.view.addDiyDom)for (var a =
            g.getRoot(b); a.createdNodes.length > 0;) {
            var c = a.createdNodes.shift();
            j.apply(b.view.addDiyDom, [b.treeId, c]);
            b.callback.onNodeCreated && b.treeObj.trigger(e.event.NODECREATED, [b.treeId, c])
        }
    }, createNodes: function (b, a, c, d) {
        if (c && c.length != 0) {
            var f = g.getRoot(b), h = b.data.key.children, h = !d || d.open || !!k("#" + d[h][0].tId).get(0);
            f.createdNodes = [];
            a = i.appendNodes(b, a, c, d, !0, h);
            d ? (d = k("#" + d.tId + e.id.UL), d.get(0) && d.append(a.join(""))) : b.treeObj.append(a.join(""));
            i.createNodeCallback(b)
        }
    }, destroy: function (b) {
        b &&
        (g.initCache(b), g.initRoot(b), m.unbindTree(b), m.unbindEvent(b), b.treeObj.empty())
    }, expandCollapseNode: function (b, a, c, d, f) {
        var h = g.getRoot(b), l = b.data.key.children;
        if (a) {
            if (h.expandTriggerFlag) {
                var p = f, f = function () {
                    p && p();
                    a.open ? b.treeObj.trigger(e.event.EXPAND, [b.treeId, a]) : b.treeObj.trigger(e.event.COLLAPSE, [b.treeId, a])
                };
                h.expandTriggerFlag = !1
            }
            if (!a.open && a.isParent && (!k("#" + a.tId + e.id.UL).get(0) || a[l] && a[l].length > 0 && !k("#" + a[l][0].tId).get(0)))i.appendParentULDom(b, a), i.createNodeCallback(b);
            if (a.open == c)j.apply(f, []); else {
                var c = k("#" + a.tId + e.id.UL), h = k("#" + a.tId + e.id.SWITCH), n = k("#" + a.tId + e.id.ICON);
                a.isParent ? (a.open = !a.open, a.iconOpen && a.iconClose && n.attr("style", i.makeNodeIcoStyle(b, a)), a.open ? (i.replaceSwitchClass(a, h, e.folder.OPEN), i.replaceIcoClass(a, n, e.folder.OPEN), d == !1 || b.view.expandSpeed == "" ? (c.show(), j.apply(f, [])) : a[l] && a[l].length > 0 ? c.slideDown(b.view.expandSpeed, f) : (c.show(), j.apply(f, []))) : (i.replaceSwitchClass(a, h, e.folder.CLOSE), i.replaceIcoClass(a, n, e.folder.CLOSE),
                    d == !1 || b.view.expandSpeed == "" || !(a[l] && a[l].length > 0) ? (c.hide(), j.apply(f, [])) : c.slideUp(b.view.expandSpeed, f))) : j.apply(f, [])
            }
        } else j.apply(f, [])
    }, expandCollapseParentNode: function (b, a, c, d, f) {
        a && (a.parentTId ? (i.expandCollapseNode(b, a, c, d), a.parentTId && i.expandCollapseParentNode(b, a.getParentNode(), c, d, f)) : i.expandCollapseNode(b, a, c, d, f))
    }, expandCollapseSonNode: function (b, a, c, d, f) {
        var h = g.getRoot(b), e = b.data.key.children, h = a ? a[e] : h[e], e = a ? !1 : d, j = g.getRoot(b).expandTriggerFlag;
        g.getRoot(b).expandTriggerFlag = !1;
        if (h)for (var k = 0, m = h.length; k < m; k++)h[k] && i.expandCollapseSonNode(b, h[k], c, e);
        g.getRoot(b).expandTriggerFlag = j;
        i.expandCollapseNode(b, a, c, d, f)
    }, makeDOMNodeIcon: function (b, a, c) {
        var d = g.getNodeName(a, c), d = a.view.nameIsHTML ? d : d.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
        b.push("<span id='", c.tId, e.id.ICON, "' title='' treeNode", e.id.ICON, " class='", i.makeNodeIcoClass(a, c), "' style='", i.makeNodeIcoStyle(a, c), "'></span><span id='", c.tId, e.id.SPAN, "'>", d, "</span>")
    }, makeDOMNodeLine: function (b, a, c) {
        b.push("<span id='", c.tId, e.id.SWITCH, "' title='' class='", i.makeNodeLineClass(a, c), "' treeNode", e.id.SWITCH, "></span>")
    }, makeDOMNodeMainAfter: function (b) {
        b.push("</li>")
    }, makeDOMNodeMainBefore: function (b, a, c) {
        b.push("<li id='", c.tId, "' class='level", c.level, "' tabindex='0' hidefocus='true' treenode>")
    }, makeDOMNodeNameAfter: function (b) {
        b.push("</a>")
    }, makeDOMNodeNameBefore: function (b, a, c) {
        var d = g.getNodeTitle(a, c), f = i.makeNodeUrl(a, c), h = i.makeNodeFontCss(a, c), l = [], k;
        for (k in h)l.push(k, ":", h[k],
            ";");
        b.push("<a id='", c.tId, e.id.A, "' class='level", c.level, "' treeNode", e.id.A, ' onclick="', c.click || "", '" ', f != null && f.length > 0 ? "href='" + f + "'" : "", " target='", i.makeNodeTarget(c), "' style='", l.join(""), "'");
        j.apply(a.view.showTitle, [a.treeId, c], a.view.showTitle) && d && b.push("title='", d.replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;"), "'");
        b.push(">")
    }, makeNodeFontCss: function (b, a) {
        var c = j.apply(b.view.fontCss, [b.treeId, a], b.view.fontCss);
        return c && typeof c != "function" ? c : {}
    }, makeNodeIcoClass: function (b, a) {
        var c = ["ico"];
        a.isAjaxing || (c[0] = (a.iconSkin ? a.iconSkin + "_" : "") + c[0], a.isParent ? c.push(a.open ? e.folder.OPEN : e.folder.CLOSE) : c.push(e.folder.DOCU));
        return"button " + c.join("_")
    }, makeNodeIcoStyle: function (b, a) {
        var c = [];
        if (!a.isAjaxing) {
            var d = a.isParent && a.iconOpen && a.iconClose ? a.open ? a.iconOpen : a.iconClose : a.icon;
            d && c.push("background:url(", d, ") 0 0 no-repeat;");
            (b.view.showIcon == !1 || !j.apply(b.view.showIcon, [b.treeId, a], !0)) && c.push("width:0px;height:0px;")
        }
        return c.join("")
    }, makeNodeLineClass: function (b, a) {
        var c = [];
        b.view.showLine ? a.level == 0 && a.isFirstNode && a.isLastNode ? c.push(e.line.ROOT) : a.level == 0 && a.isFirstNode ? c.push(e.line.ROOTS) : a.isLastNode ? c.push(e.line.BOTTOM) : c.push(e.line.CENTER) : c.push(e.line.NOLINE);
        a.isParent ? c.push(a.open ? e.folder.OPEN : e.folder.CLOSE) : c.push(e.folder.DOCU);
        return i.makeNodeLineClassEx(a) + c.join("_")
    }, makeNodeLineClassEx: function (b) {
        return"button level" + b.level + " switch "
    }, makeNodeTarget: function (b) {
        return b.target || "_blank"
    }, makeNodeUrl: function (b, a) {
        var c = b.data.key.url;
        return a[c] ? a[c] : null
    }, makeUlHtml: function (b, a, c, d) {
        c.push("<ul id='", a.tId, e.id.UL, "' class='level", a.level, " ", i.makeUlLineClass(b, a), "' style='display:", a.open ? "block" : "none", "'>");
        c.push(d);
        c.push("</ul>")
    }, makeUlLineClass: function (b, a) {
        return b.view.showLine && !a.isLastNode ? e.line.LINE : ""
    }, removeChildNodes: function (b, a) {
        if (a) {
            var c = b.data.key.children, d = a[c];
            if (d) {
                for (var f = 0, h = d.length; f < h; f++)g.removeNodeCache(b, d[f]);
                g.removeSelectedNode(b);
                delete a[c];
                b.data.keep.parent ? k("#" + a.tId + e.id.UL).empty() :
                    (a.isParent = !1, a.open = !1, c = k("#" + a.tId + e.id.SWITCH), d = k("#" + a.tId + e.id.ICON), i.replaceSwitchClass(a, c, e.folder.DOCU), i.replaceIcoClass(a, d, e.folder.DOCU), k("#" + a.tId + e.id.UL).remove())
            }
        }
    }, setFirstNode: function (b, a) {
        var c = b.data.key.children;
        if (a[c].length > 0)a[c][0].isFirstNode = !0
    }, setLastNode: function (b, a) {
        var c = b.data.key.children, d = a[c].length;
        if (d > 0)a[c][d - 1].isLastNode = !0
    }, removeNode: function (b, a) {
        var c = g.getRoot(b), d = b.data.key.children, f = a.parentTId ? a.getParentNode() : c;
        a.isFirstNode = !1;
        a.isLastNode = !1;
        a.getPreNode = function () {
            return null
        };
        a.getNextNode = function () {
            return null
        };
        if (g.getNodeCache(b, a.tId)) {
            k("#" + a.tId).remove();
            g.removeNodeCache(b, a);
            g.removeSelectedNode(b, a);
            for (var h = 0, l = f[d].length; h < l; h++)if (f[d][h].tId == a.tId) {
                f[d].splice(h, 1);
                break
            }
            i.setFirstNode(b, f);
            i.setLastNode(b, f);
            var j, h = f[d].length;
            if (!b.data.keep.parent && h == 0)f.isParent = !1, f.open = !1, h = k("#" + f.tId + e.id.UL), l = k("#" + f.tId + e.id.SWITCH), j = k("#" + f.tId + e.id.ICON), i.replaceSwitchClass(f, l, e.folder.DOCU), i.replaceIcoClass(f,
                j, e.folder.DOCU), h.css("display", "none"); else if (b.view.showLine && h > 0) {
                var n = f[d][h - 1], h = k("#" + n.tId + e.id.UL), l = k("#" + n.tId + e.id.SWITCH);
                j = k("#" + n.tId + e.id.ICON);
                f == c ? f[d].length == 1 ? i.replaceSwitchClass(n, l, e.line.ROOT) : (c = k("#" + f[d][0].tId + e.id.SWITCH), i.replaceSwitchClass(f[d][0], c, e.line.ROOTS), i.replaceSwitchClass(n, l, e.line.BOTTOM)) : i.replaceSwitchClass(n, l, e.line.BOTTOM);
                h.removeClass(e.line.LINE)
            }
        }
    }, replaceIcoClass: function (b, a, c) {
        if (a && !b.isAjaxing && (b = a.attr("class"), b != void 0)) {
            b = b.split("_");
            switch (c) {
                case e.folder.OPEN:
                case e.folder.CLOSE:
                case e.folder.DOCU:
                    b[b.length - 1] = c
            }
            a.attr("class", b.join("_"))
        }
    }, replaceSwitchClass: function (b, a, c) {
        if (a) {
            var d = a.attr("class");
            if (d != void 0) {
                d = d.split("_");
                switch (c) {
                    case e.line.ROOT:
                    case e.line.ROOTS:
                    case e.line.CENTER:
                    case e.line.BOTTOM:
                    case e.line.NOLINE:
                        d[0] = i.makeNodeLineClassEx(b) + c;
                        break;
                    case e.folder.OPEN:
                    case e.folder.CLOSE:
                    case e.folder.DOCU:
                        d[1] = c
                }
                a.attr("class", d.join("_"));
                c !== e.folder.DOCU ? a.removeAttr("disabled") : a.attr("disabled", "disabled")
            }
        }
    },
        selectNode: function (b, a, c) {
            c || i.cancelPreSelectedNode(b);
            k("#" + a.tId + e.id.A).addClass(e.node.CURSELECTED);
            g.addSelectedNode(b, a)
        }, setNodeFontCss: function (b, a) {
            var c = k("#" + a.tId + e.id.A), d = i.makeNodeFontCss(b, a);
            d && c.css(d)
        }, setNodeLineIcos: function (b, a) {
            if (a) {
                var c = k("#" + a.tId + e.id.SWITCH), d = k("#" + a.tId + e.id.UL), f = k("#" + a.tId + e.id.ICON), h = i.makeUlLineClass(b, a);
                h.length == 0 ? d.removeClass(e.line.LINE) : d.addClass(h);
                c.attr("class", i.makeNodeLineClass(b, a));
                a.isParent ? c.removeAttr("disabled") : c.attr("disabled",
                    "disabled");
                f.removeAttr("style");
                f.attr("style", i.makeNodeIcoStyle(b, a));
                f.attr("class", i.makeNodeIcoClass(b, a))
            }
        }, setNodeName: function (b, a) {
            var c = g.getNodeTitle(b, a), d = k("#" + a.tId + e.id.SPAN);
            d.empty();
            b.view.nameIsHTML ? d.html(g.getNodeName(b, a)) : d.text(g.getNodeName(b, a));
            j.apply(b.view.showTitle, [b.treeId, a], b.view.showTitle) && k("#" + a.tId + e.id.A).attr("title", !c ? "" : c)
        }, setNodeTarget: function (b) {
            k("#" + b.tId + e.id.A).attr("target", i.makeNodeTarget(b))
        }, setNodeUrl: function (b, a) {
            var c = k("#" + a.tId + e.id.A),
                d = i.makeNodeUrl(b, a);
            d == null || d.length == 0 ? c.removeAttr("href") : c.attr("href", d)
        }, switchNode: function (b, a) {
            a.open || !j.canAsync(b, a) ? i.expandCollapseNode(b, a, !a.open) : b.async.enable ? i.asyncNode(b, a) || i.expandCollapseNode(b, a, !a.open) : a && i.expandCollapseNode(b, a, !a.open)
        }};
    k.fn.zTree = {consts: {event: {NODECREATED: "ztree_nodeCreated", CLICK: "ztree_click", EXPAND: "ztree_expand", COLLAPSE: "ztree_collapse", ASYNC_SUCCESS: "ztree_async_success", ASYNC_ERROR: "ztree_async_error"}, id: {A: "_a", ICON: "_ico", SPAN: "_span",
        SWITCH: "_switch", UL: "_ul"}, line: {ROOT: "root", ROOTS: "roots", CENTER: "center", BOTTOM: "bottom", NOLINE: "noline", LINE: "line"}, folder: {OPEN: "open", CLOSE: "close", DOCU: "docu"}, node: {CURSELECTED: "curSelectedNode"}}, _z: {tools: j, view: i, event: m, data: g}, getZTreeObj: function (b) {
        return(b = g.getZTreeTools(b)) ? b : null
    }, destroy: function (b) {
        if (b && b.length > 0)i.destroy(g.getSetting(b)); else for (var a in r)i.destroy(r[a])
    }, init: function (b, a, c) {
        var d = j.clone(L);
        k.extend(!0, d, a);
        d.treeId = b.attr("id");
        d.treeObj = b;
        d.treeObj.empty();
        r[d.treeId] = d;
        g.initRoot(d);
        b = g.getRoot(d);
        a = d.data.key.children;
        c = c ? j.clone(j.isArray(c) ? c : [c]) : [];
        b[a] = d.data.simpleData.enable ? g.transformTozTreeFormat(d, c) : c;
        g.initCache(d);
        m.unbindTree(d);
        m.bindTree(d);
        m.unbindEvent(d);
        m.bindEvent(d);
        c = {setting: d, addNodes: function (a, b, c) {
            function e() {
                i.addNodes(d, a, g, c == !0)
            }

            if (!b)return null;
            a || (a = null);
            if (a && !a.isParent && d.data.keep.leaf)return null;
            var g = j.clone(j.isArray(b) ? b : [b]);
            j.canAsync(d,
                a) ? i.asyncNode(d, a, c, e) : e();
            return g
        }, cancelSelectedNode: function (a) {
            i.cancelPreSelectedNode(this.setting, a)
        }, destroy: function () {
            i.destroy(this.setting)
        }, expandAll: function (a) {
            a = !!a;
            i.expandCollapseSonNode(this.setting, null, a, !0);
            return a
        }, expandNode: function (a, b, c, e, m) {
            if (!a || !a.isParent)return null;
            b !== !0 && b !== !1 && (b = !a.open);
            if ((m = !!m) && b && j.apply(d.callback.beforeExpand, [d.treeId, a], !0) == !1)return null; else if (m && !b && j.apply(d.callback.beforeCollapse, [d.treeId, a], !0) == !1)return null;
            b && a.parentTId &&
            i.expandCollapseParentNode(this.setting, a.getParentNode(), b, !1);
            if (b === a.open && !c)return null;
            g.getRoot(d).expandTriggerFlag = m;
            if (c)i.expandCollapseSonNode(this.setting, a, b, !0, function () {
                if (e !== !1)try {
                    k("#" + a.tId).focus().blur()
                } catch (b) {
                }
            }); else if (a.open = !b, i.switchNode(this.setting, a), e !== !1)try {
                k("#" + a.tId).focus().blur()
            } catch (q) {
            }
            return b
        }, getNodes: function () {
            return g.getNodes(this.setting)
        }, getNodeByParam: function (a, b, c) {
            return!a ? null : g.getNodeByParam(this.setting, c ? c[this.setting.data.key.children] :
                g.getNodes(this.setting), a, b)
        }, getNodeByTId: function (a) {
            return g.getNodeCache(this.setting, a)
        }, getNodesByParam: function (a, b, c) {
            return!a ? null : g.getNodesByParam(this.setting, c ? c[this.setting.data.key.children] : g.getNodes(this.setting), a, b)
        }, getNodesByParamFuzzy: function (a, b, c) {
            return!a ? null : g.getNodesByParamFuzzy(this.setting, c ? c[this.setting.data.key.children] : g.getNodes(this.setting), a, b)
        }, getNodesByFilter: function (a, b, c, d) {
            b = !!b;
            return!a || typeof a != "function" ? b ? null : [] : g.getNodesByFilter(this.setting,
                c ? c[this.setting.data.key.children] : g.getNodes(this.setting), a, b, d)
        }, getNodeIndex: function (a) {
            if (!a)return null;
            for (var b = d.data.key.children, c = a.parentTId ? a.getParentNode() : g.getRoot(this.setting), e = 0, i = c[b].length; e < i; e++)if (c[b][e] == a)return e;
            return-1
        }, getSelectedNodes: function () {
            for (var a = [], b = g.getRoot(this.setting).curSelectedList, c = 0, d = b.length; c < d; c++)a.push(b[c]);
            return a
        }, isSelectedNode: function (a) {
            return g.isSelectedNode(this.setting, a)
        }, reAsyncChildNodes: function (a, b, c) {
            if (this.setting.async.enable) {
                var j =
                    !a;
                j && (a = g.getRoot(this.setting));
                if (b == "refresh") {
                    for (var b = this.setting.data.key.children, m = 0, q = a[b].length; m < q; m++)g.removeNodeCache(d, a[b][m]);
                    g.removeSelectedNode(d);
                    a[b] = [];
                    j ? this.setting.treeObj.empty() : k("#" + a.tId + e.id.UL).empty()
                }
                i.asyncNode(this.setting, j ? null : a, !!c)
            }
        }, refresh: function () {
            this.setting.treeObj.empty();
            var a = g.getRoot(this.setting), b = a[this.setting.data.key.children];
            g.initRoot(this.setting);
            a[this.setting.data.key.children] = b;
            g.initCache(this.setting);
            i.createNodes(this.setting,
                0, a[this.setting.data.key.children])
        }, removeChildNodes: function (a) {
            if (!a)return null;
            var b = a[d.data.key.children];
            i.removeChildNodes(d, a);
            return b ? b : null
        }, removeNode: function (a, b) {
            a && (b = !!b, b && j.apply(d.callback.beforeRemove, [d.treeId, a], !0) == !1 || (i.removeNode(d, a), b && this.setting.treeObj.trigger(e.event.REMOVE, [d.treeId, a])))
        }, selectNode: function (a, b) {
            if (a && j.uCanDo(this.setting)) {
                b = d.view.selectedMulti && b;
                if (a.parentTId)i.expandCollapseParentNode(this.setting, a.getParentNode(), !0, !1, function () {
                    try {
                        k("#" +
                            a.tId).focus().blur()
                    } catch (b) {
                    }
                }); else try {
                    k("#" + a.tId).focus().blur()
                } catch (c) {
                }
                i.selectNode(this.setting, a, b)
            }
        }, transformTozTreeNodes: function (a) {
            return g.transformTozTreeFormat(this.setting, a)
        }, transformToArray: function (a) {
            return g.transformToArrayFormat(this.setting, a)
        }, updateNode: function (a) {
            a && k("#" + a.tId).get(0) && j.uCanDo(this.setting) && (i.setNodeName(this.setting, a), i.setNodeTarget(a), i.setNodeUrl(this.setting, a), i.setNodeLineIcos(this.setting, a), i.setNodeFontCss(this.setting, a))
        }};
        b.treeTools =
            c;
        g.setZTreeTools(d, c);
        b[a] && b[a].length > 0 ? i.createNodes(d, 0, b[a]) : d.async.enable && d.async.url && d.async.url !== "" && i.asyncNode(d);
        return c
    }};
    var M = k.fn.zTree, e = M.consts
})(jQuery);

/*
 * JQuery zTree excheck 3.5
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2012-11-20
 */
(function (m) {
    var p, q, r, n = {event: {CHECK: "ztree_check"}, id: {CHECK: "_check"}, checkbox: {STYLE: "checkbox", DEFAULT: "chk", DISABLED: "disable", FALSE: "false", TRUE: "true", FULL: "full", PART: "part", FOCUS: "focus"}, radio: {STYLE: "radio", TYPE_ALL: "all", TYPE_LEVEL: "level"}}, v = {check: {enable: !1, autoCheckTrigger: !1, chkStyle: n.checkbox.STYLE, nocheckInherit: !1, radioType: n.radio.TYPE_LEVEL, chkboxType: {Y: "ps", N: "ps"}}, data: {key: {checked: "checked"}}, callback: {beforeCheck: null, onCheck: null}};
    p = function (c, a) {
        if (a.chkDisabled === !0)return!1;
        var b = f.getSetting(c.data.treeId), d = b.data.key.checked;
        if (k.apply(b.callback.beforeCheck, [b.treeId, a], !0) == !1)return!0;
        a[d] = !a[d];
        e.checkNodeRelation(b, a);
        d = m("#" + a.tId + j.id.CHECK);
        e.setChkClass(b, d, a);
        e.repairParentChkClassWithSelf(b, a);
        b.treeObj.trigger(j.event.CHECK, [c, b.treeId, a]);
        return!0
    };
    q = function (c, a) {
        if (a.chkDisabled === !0)return!1;
        var b = f.getSetting(c.data.treeId), d = m("#" + a.tId + j.id.CHECK);
        a.check_Focus = !0;
        e.setChkClass(b, d, a);
        return!0
    };
    r = function (c, a) {
        if (a.chkDisabled === !0)return!1;
        var b = f.getSetting(c.data.treeId), d = m("#" + a.tId + j.id.CHECK);
        a.check_Focus = !1;
        e.setChkClass(b, d, a);
        return!0
    };
    m.extend(!0, m.fn.zTree.consts, n);
    m.extend(!0, m.fn.zTree._z, {tools: {}, view: {checkNodeRelation: function (c, a) {
        var b, d, g, l = c.data.key.children, h = c.data.key.checked;
        b = j.radio;
        if (c.check.chkStyle == b.STYLE) {
            var i = f.getRadioCheckedList(c);
            if (a[h])if (c.check.radioType == b.TYPE_ALL) {
                for (d = i.length - 1; d >= 0; d--)b = i[d], b[h] = !1, i.splice(d, 1), e.setChkClass(c, m("#" + b.tId + j.id.CHECK), b), b.parentTId != a.parentTId &&
                    e.repairParentChkClassWithSelf(c, b);
                i.push(a)
            } else {
                i = a.parentTId ? a.getParentNode() : f.getRoot(c);
                for (d = 0, g = i[l].length; d < g; d++)b = i[l][d], b[h] && b != a && (b[h] = !1, e.setChkClass(c, m("#" + b.tId + j.id.CHECK), b))
            } else if (c.check.radioType == b.TYPE_ALL)for (d = 0, g = i.length; d < g; d++)if (a == i[d]) {
                i.splice(d, 1);
                break
            }
        } else a[h] && (!a[l] || a[l].length == 0 || c.check.chkboxType.Y.indexOf("s") > -1) && e.setSonNodeCheckBox(c, a, !0), !a[h] && (!a[l] || a[l].length == 0 || c.check.chkboxType.N.indexOf("s") > -1) && e.setSonNodeCheckBox(c, a, !1),
            a[h] && c.check.chkboxType.Y.indexOf("p") > -1 && e.setParentNodeCheckBox(c, a, !0), !a[h] && c.check.chkboxType.N.indexOf("p") > -1 && e.setParentNodeCheckBox(c, a, !1)
    }, makeChkClass: function (c, a) {
        var b = c.data.key.checked, d = j.checkbox, g = j.radio, e = "", e = a.chkDisabled === !0 ? d.DISABLED : a.halfCheck ? d.PART : c.check.chkStyle == g.STYLE ? a.check_Child_State < 1 ? d.FULL : d.PART : a[b] ? a.check_Child_State === 2 || a.check_Child_State === -1 ? d.FULL : d.PART : a.check_Child_State < 1 ? d.FULL : d.PART, b = c.check.chkStyle + "_" + (a[b] ? d.TRUE : d.FALSE) + "_" +
            e, b = a.check_Focus && a.chkDisabled !== !0 ? b + "_" + d.FOCUS : b;
        return"button " + d.DEFAULT + " " + b
    }, repairAllChk: function (c, a) {
        if (c.check.enable && c.check.chkStyle === j.checkbox.STYLE)for (var b = c.data.key.checked, d = c.data.key.children, g = f.getRoot(c), l = 0, h = g[d].length; l < h; l++) {
            var i = g[d][l];
            i.nocheck !== !0 && (i[b] = a);
            e.setSonNodeCheckBox(c, i, a)
        }
    }, repairChkClass: function (c, a) {
        if (a) {
            f.makeChkFlag(c, a);
            var b = m("#" + a.tId + j.id.CHECK);
            e.setChkClass(c, b, a)
        }
    }, repairParentChkClass: function (c, a) {
        if (a && a.parentTId) {
            var b = a.getParentNode();
            e.repairChkClass(c, b);
            e.repairParentChkClass(c, b)
        }
    }, repairParentChkClassWithSelf: function (c, a) {
        if (a) {
            var b = c.data.key.children;
            a[b] && a[b].length > 0 ? e.repairParentChkClass(c, a[b][0]) : e.repairParentChkClass(c, a)
        }
    }, repairSonChkDisabled: function (c, a, b) {
        if (a) {
            var d = c.data.key.children;
            if (a.chkDisabled != b)a.chkDisabled = b, a.nocheck !== !0 && e.repairChkClass(c, a);
            if (a[d])for (var g = 0, l = a[d].length; g < l; g++)e.repairSonChkDisabled(c, a[d][g], b)
        }
    }, repairParentChkDisabled: function (c, a, b) {
        if (a) {
            if (a.chkDisabled != b)a.chkDisabled =
                b, a.nocheck !== !0 && e.repairChkClass(c, a);
            e.repairParentChkDisabled(c, a.getParentNode(), b)
        }
    }, setChkClass: function (c, a, b) {
        a && (b.nocheck === !0 ? a.hide() : a.show(), a.removeClass(), a.addClass(e.makeChkClass(c, b)))
    }, setParentNodeCheckBox: function (c, a, b, d) {
        var g = c.data.key.children, l = c.data.key.checked, h = m("#" + a.tId + j.id.CHECK);
        d || (d = a);
        f.makeChkFlag(c, a);
        a.nocheck !== !0 && a.chkDisabled !== !0 && (a[l] = b, e.setChkClass(c, h, a), c.check.autoCheckTrigger && a != d && a.nocheck !== !0 && c.treeObj.trigger(j.event.CHECK, [c.treeId,
            a]));
        if (a.parentTId) {
            h = !0;
            if (!b)for (var g = a.getParentNode()[g], i = 0, o = g.length; i < o; i++)if (g[i].nocheck !== !0 && g[i][l] || g[i].nocheck === !0 && g[i].check_Child_State > 0) {
                h = !1;
                break
            }
            h && e.setParentNodeCheckBox(c, a.getParentNode(), b, d)
        }
    }, setSonNodeCheckBox: function (c, a, b, d) {
        if (a) {
            var g = c.data.key.children, l = c.data.key.checked, h = m("#" + a.tId + j.id.CHECK);
            d || (d = a);
            var i = !1;
            if (a[g])for (var o = 0, k = a[g].length; o < k && a.chkDisabled !== !0; o++) {
                var n = a[g][o];
                e.setSonNodeCheckBox(c, n, b, d);
                n.chkDisabled === !0 && (i = !0)
            }
            if (a !=
                f.getRoot(c) && a.chkDisabled !== !0) {
                i && a.nocheck !== !0 && f.makeChkFlag(c, a);
                if (a.nocheck !== !0) {
                    if (a[l] = b, !i)a.check_Child_State = a[g] && a[g].length > 0 ? b ? 2 : 0 : -1
                } else a.check_Child_State = -1;
                e.setChkClass(c, h, a);
                c.check.autoCheckTrigger && a != d && a.nocheck !== !0 && c.treeObj.trigger(j.event.CHECK, [c.treeId, a])
            }
        }
    }}, event: {}, data: {getRadioCheckedList: function (c) {
        for (var a = f.getRoot(c).radioCheckedList, b = 0, d = a.length; b < d; b++)f.getNodeCache(c, a[b].tId) || (a.splice(b, 1), b--, d--);
        return a
    }, getCheckStatus: function (c, a) {
        if (!c.check.enable ||
            a.nocheck)return null;
        var b = c.data.key.checked;
        return{checked: a[b], half: a.halfCheck ? a.halfCheck : c.check.chkStyle == j.radio.STYLE ? a.check_Child_State === 2 : a[b] ? a.check_Child_State > -1 && a.check_Child_State < 2 : a.check_Child_State > 0}
    }, getTreeCheckedNodes: function (c, a, b, d) {
        if (!a)return[];
        for (var g = c.data.key.children, e = c.data.key.checked, h = b && c.check.chkStyle == j.radio.STYLE && c.check.radioType == j.radio.TYPE_ALL, d = !d ? [] : d, i = 0, o = a.length; i < o; i++) {
            if (a[i].nocheck !== !0 && a[i][e] == b && (d.push(a[i]), h))break;
            f.getTreeCheckedNodes(c,
                a[i][g], b, d);
            if (h && d.length > 0)break
        }
        return d
    }, getTreeChangeCheckedNodes: function (c, a, b) {
        if (!a)return[];
        for (var d = c.data.key.children, g = c.data.key.checked, b = !b ? [] : b, e = 0, h = a.length; e < h; e++)a[e].nocheck !== !0 && a[e][g] != a[e].checkedOld && b.push(a[e]), f.getTreeChangeCheckedNodes(c, a[e][d], b);
        return b
    }, makeChkFlag: function (c, a) {
        if (a) {
            var b = c.data.key.children, d = c.data.key.checked, g = -1;
            if (a[b])for (var e = !1, h = 0, i = a[b].length; h < i; h++) {
                var f = a[b][h], k = -1;
                if (c.check.chkStyle == j.radio.STYLE)if (k = f.nocheck === !0 ?
                    f.check_Child_State : f.halfCheck === !0 ? 2 : f.nocheck !== !0 && f[d] ? 2 : f.check_Child_State > 0 ? 2 : 0, k == 2) {
                    g = 2;
                    break
                } else k == 0 && (g = 0); else if (c.check.chkStyle == j.checkbox.STYLE) {
                    k = f.nocheck === !0 ? f.check_Child_State : f.halfCheck === !0 ? 1 : f.nocheck !== !0 && f[d] ? f.check_Child_State === -1 || f.check_Child_State === 2 ? 2 : 1 : f.check_Child_State > 0 ? 1 : 0;
                    if (k === 1) {
                        g = 1;
                        break
                    } else if (k === 2 && e && k !== g) {
                        g = 1;
                        break
                    } else if (g === 2 && k > -1 && k < 2) {
                        g = 1;
                        break
                    } else k > -1 && (g = k);
                    e || (e = f.nocheck !== !0)
                }
            }
            a.check_Child_State = g
        }
    }}});
    var n = m.fn.zTree, k = n._z.tools,
        j = n.consts, e = n._z.view, f = n._z.data;
    f.exSetting(v);
    f.addInitBind(function (c) {
        c.treeObj.bind(j.event.CHECK, function (a, b, d, e) {
            k.apply(c.callback.onCheck, [b ? b : a, d, e])
        })
    });
    f.addInitUnBind(function (c) {
        c.treeObj.unbind(j.event.CHECK)
    });
    f.addInitCache(function () {
    });
    f.addInitNode(function (c, a, b, d) {
        if (b) {
            a = c.data.key.checked;
            typeof b[a] == "string" && (b[a] = k.eqs(b[a], "true"));
            b[a] = !!b[a];
            b.checkedOld = b[a];
            if (typeof b.nocheck == "string")b.nocheck = k.eqs(b.nocheck, "true");
            b.nocheck = !!b.nocheck || c.check.nocheckInherit &&
                d && !!d.nocheck;
            if (typeof b.chkDisabled == "string")b.chkDisabled = k.eqs(b.chkDisabled, "true");
            b.chkDisabled = !!b.chkDisabled || d && !!d.chkDisabled;
            if (typeof b.halfCheck == "string")b.halfCheck = k.eqs(b.halfCheck, "true");
            b.halfCheck = !!b.halfCheck;
            b.check_Child_State = -1;
            b.check_Focus = !1;
            b.getCheckStatus = function () {
                return f.getCheckStatus(c, b)
            }
        }
    });
    f.addInitProxy(function (c) {
        var a = c.target, b = f.getSetting(c.data.treeId), d = "", e = null, l = "", h = null;
        if (k.eqs(c.type, "mouseover")) {
            if (b.check.enable && k.eqs(a.tagName, "span") &&
                a.getAttribute("treeNode" + j.id.CHECK) !== null)d = a.parentNode.id, l = "mouseoverCheck"
        } else if (k.eqs(c.type, "mouseout")) {
            if (b.check.enable && k.eqs(a.tagName, "span") && a.getAttribute("treeNode" + j.id.CHECK) !== null)d = a.parentNode.id, l = "mouseoutCheck"
        } else if (k.eqs(c.type, "click") && b.check.enable && k.eqs(a.tagName, "span") && a.getAttribute("treeNode" + j.id.CHECK) !== null)d = a.parentNode.id, l = "checkNode";
        if (d.length > 0)switch (e = f.getNodeCache(b, d), l) {
            case "checkNode":
                h = p;
                break;
            case "mouseoverCheck":
                h = q;
                break;
            case "mouseoutCheck":
                h =
                    r
        }
        return{stop: !1, node: e, nodeEventType: l, nodeEventCallback: h, treeEventType: "", treeEventCallback: null}
    });
    f.addInitRoot(function (c) {
        f.getRoot(c).radioCheckedList = []
    });
    f.addBeforeA(function (c, a, b) {
        var d = c.data.key.checked;
        c.check.enable && (f.makeChkFlag(c, a), c.check.chkStyle == j.radio.STYLE && c.check.radioType == j.radio.TYPE_ALL && a[d] && f.getRoot(c).radioCheckedList.push(a), b.push("<span ID='", a.tId, j.id.CHECK, "' class='", e.makeChkClass(c, a), "' treeNode", j.id.CHECK, a.nocheck === !0 ? " style='display:none;'" :
            "", "></span>"))
    });
    f.addZTreeTools(function (c, a) {
        a.checkNode = function (a, b, f, h) {
            var i = this.setting.data.key.checked;
            if (a.chkDisabled !== !0 && (b !== !0 && b !== !1 && (b = !a[i]), h = !!h, (a[i] !== b || f) && !(h && k.apply(this.setting.callback.beforeCheck, [this.setting.treeId, a], !0) == !1) && k.uCanDo(this.setting) && this.setting.check.enable && a.nocheck !== !0))a[i] = b, b = m("#" + a.tId + j.id.CHECK), (f || this.setting.check.chkStyle === j.radio.STYLE) && e.checkNodeRelation(this.setting, a), e.setChkClass(this.setting, b, a), e.repairParentChkClassWithSelf(this.setting,
                a), h && c.treeObj.trigger(j.event.CHECK, [null, c.treeId, a])
        };
        a.checkAllNodes = function (a) {
            e.repairAllChk(this.setting, !!a)
        };
        a.getCheckedNodes = function (a) {
            var b = this.setting.data.key.children;
            return f.getTreeCheckedNodes(this.setting, f.getRoot(c)[b], a !== !1)
        };
        a.getChangeCheckedNodes = function () {
            var a = this.setting.data.key.children;
            return f.getTreeChangeCheckedNodes(this.setting, f.getRoot(c)[a])
        };
        a.setChkDisabled = function (a, b) {
            b = !!b;
            e.repairSonChkDisabled(this.setting, a, b);
            b || e.repairParentChkDisabled(this.setting,
                a, b)
        };
        var b = a.updateNode;
        a.updateNode = function (c, f) {
            b && b.apply(a, arguments);
            if (c && this.setting.check.enable && m("#" + c.tId).get(0) && k.uCanDo(this.setting)) {
                var l = m("#" + c.tId + j.id.CHECK);
                (f == !0 || this.setting.check.chkStyle === j.radio.STYLE) && e.checkNodeRelation(this.setting, c);
                e.setChkClass(this.setting, l, c);
                e.repairParentChkClassWithSelf(this.setting, c)
            }
        }
    });
    var s = e.createNodes;
    e.createNodes = function (c, a, b, d) {
        s && s.apply(e, arguments);
        b && e.repairParentChkClassWithSelf(c, d)
    };
    var t = e.removeNode;
    e.removeNode =
        function (c, a) {
            var b = a.getParentNode();
            t && t.apply(e, arguments);
            a && b && (e.repairChkClass(c, b), e.repairParentChkClass(c, b))
        };
    var u = e.appendNodes;
    e.appendNodes = function (c, a, b, d, g, j) {
        var h = "";
        u && (h = u.apply(e, arguments));
        d && f.makeChkFlag(c, d);
        return h
    }
})(jQuery);

/*
 * JQuery zTree exedit 3.5
 * http://zTree.me/
 *
 * Copyright (c) 2010 Hunter.z
 *
 * Licensed same as jquery - MIT License
 * http://www.opensource.org/licenses/mit-license.php
 *
 * email: hunter.z@263.net
 * Date: 2012-11-20
 */
(function (k) {
    var F = {event: {DRAG: "ztree_drag", DROP: "ztree_drop", REMOVE: "ztree_remove", RENAME: "ztree_rename"}, id: {EDIT: "_edit", INPUT: "_input", REMOVE: "_remove"}, move: {TYPE_INNER: "inner", TYPE_PREV: "prev", TYPE_NEXT: "next"}, node: {CURSELECTED_EDIT: "curSelectedNode_Edit", TMPTARGET_TREE: "tmpTargetzTree", TMPTARGET_NODE: "tmpTargetNode"}}, D = {onHoverOverNode: function (b, a) {
        var c = p.getSetting(b.data.treeId), d = p.getRoot(c);
        if (d.curHoverNode != a)D.onHoverOutNode(b);
        d.curHoverNode = a;
        f.addHoverDom(c, a)
    }, onHoverOutNode: function (b) {
        var b =
            p.getSetting(b.data.treeId), a = p.getRoot(b);
        if (a.curHoverNode && !p.isSelectedNode(b, a.curHoverNode))f.removeTreeDom(b, a.curHoverNode), a.curHoverNode = null
    }, onMousedownNode: function (b, a) {
        function c(b) {
            if (z.dragFlag == 0 && Math.abs(K - b.clientX) < g.edit.drag.minMoveSize && Math.abs(L - b.clientY) < g.edit.drag.minMoveSize)return!0;
            var a, c, e, j, l;
            l = g.data.key.children;
            h.noSel(g);
            k("body").css("cursor", "pointer");
            if (z.dragFlag == 0) {
                if (h.apply(g.callback.beforeDrag, [g.treeId, m], !0) == !1)return q(b), !0;
                for (a = 0, c = m.length; a <
                    c; a++) {
                    if (a == 0)z.dragNodeShowBefore = [];
                    e = m[a];
                    e.isParent && e.open ? (f.expandCollapseNode(g, e, !e.open), z.dragNodeShowBefore[e.tId] = !0) : z.dragNodeShowBefore[e.tId] = !1
                }
                z.dragFlag = 1;
                z.showHoverDom = !1;
                h.showIfameMask(g, !0);
                e = !0;
                j = -1;
                if (m.length > 1) {
                    var s = m[0].parentTId ? m[0].getParentNode()[l] : p.getNodes(g);
                    l = [];
                    for (a = 0, c = s.length; a < c; a++)if (z.dragNodeShowBefore[s[a].tId] !== void 0 && (e && j > -1 && j + 1 !== a && (e = !1), l.push(s[a]), j = a), m.length === l.length) {
                        m = l;
                        break
                    }
                }
                e && (D = m[0].getPreNode(), E = m[m.length - 1].getNextNode());
                y = k("<ul class='zTreeDragUL'></ul>");
                for (a = 0, c = m.length; a < c; a++)if (e = m[a], e.editNameFlag = !1, f.selectNode(g, e, a > 0), f.removeTreeDom(g, e), j = k("<li id='" + e.tId + "_tmp'></li>"), j.append(k("#" + e.tId + d.id.A).clone()), j.css("padding", "0"), j.children("#" + e.tId + d.id.A).removeClass(d.node.CURSELECTED), y.append(j), a == g.edit.drag.maxShowNodeNum - 1) {
                    j = k("<li id='" + e.tId + "_moretmp'><a>  ...  </a></li>");
                    y.append(j);
                    break
                }
                y.attr("id", m[0].tId + d.id.UL + "_tmp");
                y.addClass(g.treeObj.attr("class"));
                y.appendTo("body");
                t =
                    k("<span class='tmpzTreeMove_arrow'></span>");
                t.attr("id", "zTreeMove_arrow_tmp");
                t.appendTo("body");
                g.treeObj.trigger(d.event.DRAG, [b, g.treeId, m])
            }
            if (z.dragFlag == 1) {
                r && t.attr("id") == b.target.id && u && b.clientX + x.scrollLeft() + 2 > k("#" + u + d.id.A, r).offset().left ? (e = k("#" + u + d.id.A, r), b.target = e.length > 0 ? e.get(0) : b.target) : r && (r.removeClass(d.node.TMPTARGET_TREE), u && k("#" + u + d.id.A, r).removeClass(d.node.TMPTARGET_NODE + "_" + d.move.TYPE_PREV).removeClass(d.node.TMPTARGET_NODE + "_" + F.move.TYPE_NEXT).removeClass(d.node.TMPTARGET_NODE +
                    "_" + F.move.TYPE_INNER));
                u = r = null;
                G = !1;
                i = g;
                e = p.getSettings();
                for (var B in e)if (e[B].treeId && e[B].edit.enable && e[B].treeId != g.treeId && (b.target.id == e[B].treeId || k(b.target).parents("#" + e[B].treeId).length > 0))G = !0, i = e[B];
                B = x.scrollTop();
                j = x.scrollLeft();
                l = i.treeObj.offset();
                a = i.treeObj.get(0).scrollHeight;
                e = i.treeObj.get(0).scrollWidth;
                c = b.clientY + B - l.top;
                var o = i.treeObj.height() + l.top - b.clientY - B, n = b.clientX + j - l.left, H = i.treeObj.width() + l.left - b.clientX - j;
                l = c < g.edit.drag.borderMax && c > g.edit.drag.borderMin;
                var s = o < g.edit.drag.borderMax && o > g.edit.drag.borderMin, I = n < g.edit.drag.borderMax && n > g.edit.drag.borderMin, C = H < g.edit.drag.borderMax && H > g.edit.drag.borderMin, o = c > g.edit.drag.borderMin && o > g.edit.drag.borderMin && n > g.edit.drag.borderMin && H > g.edit.drag.borderMin, n = l && i.treeObj.scrollTop() <= 0, H = s && i.treeObj.scrollTop() + i.treeObj.height() + 10 >= a, M = I && i.treeObj.scrollLeft() <= 0, N = C && i.treeObj.scrollLeft() + i.treeObj.width() + 10 >= e;
                if (b.target.id && i.treeObj.find("#" + b.target.id).length > 0) {
                    for (var A = b.target; A &&
                        A.tagName && !h.eqs(A.tagName, "li") && A.id != i.treeId;)A = A.parentNode;
                    var O = !0;
                    for (a = 0, c = m.length; a < c; a++)if (e = m[a], A.id === e.tId) {
                        O = !1;
                        break
                    } else if (k("#" + e.tId).find("#" + A.id).length > 0) {
                        O = !1;
                        break
                    }
                    if (O && b.target.id && (b.target.id == A.id + d.id.A || k(b.target).parents("#" + A.id + d.id.A).length > 0))r = k(A), u = A.id
                }
                e = m[0];
                if (o && (b.target.id == i.treeId || k(b.target).parents("#" + i.treeId).length > 0)) {
                    if (!r && (b.target.id == i.treeId || n || H || M || N) && (G || !G && e.parentTId))r = i.treeObj;
                    l ? i.treeObj.scrollTop(i.treeObj.scrollTop() -
                        10) : s && i.treeObj.scrollTop(i.treeObj.scrollTop() + 10);
                    I ? i.treeObj.scrollLeft(i.treeObj.scrollLeft() - 10) : C && i.treeObj.scrollLeft(i.treeObj.scrollLeft() + 10);
                    r && r != i.treeObj && r.offset().left < i.treeObj.offset().left && i.treeObj.scrollLeft(i.treeObj.scrollLeft() + r.offset().left - i.treeObj.offset().left)
                }
                y.css({top: b.clientY + B + 3 + "px", left: b.clientX + j + 3 + "px"});
                l = a = 0;
                if (r && r.attr("id") != i.treeId) {
                    var w = u == null ? null : p.getNodeCache(i, u);
                    c = b.ctrlKey && g.edit.drag.isMove && g.edit.drag.isCopy || !g.edit.drag.isMove &&
                        g.edit.drag.isCopy;
                    a = !!(D && u === D.tId);
                    l = !!(E && u === E.tId);
                    j = e.parentTId && e.parentTId == u;
                    e = (c || !l) && h.apply(i.edit.drag.prev, [i.treeId, m, w], !!i.edit.drag.prev);
                    a = (c || !a) && h.apply(i.edit.drag.next, [i.treeId, m, w], !!i.edit.drag.next);
                    C = (c || !j) && !(i.data.keep.leaf && !w.isParent) && h.apply(i.edit.drag.inner, [i.treeId, m, w], !!i.edit.drag.inner);
                    if (!e && !a && !C) {
                        if (r = null, u = "", v = d.move.TYPE_INNER, t.css({display: "none"}), window.zTreeMoveTimer)clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId = null
                    } else {
                        c =
                            k("#" + u + d.id.A, r);
                        l = w.isLastNode ? null : k("#" + w.getNextNode().tId + d.id.A, r.next());
                        s = c.offset().top;
                        j = c.offset().left;
                        I = e ? C ? 0.25 : a ? 0.5 : 1 : -1;
                        C = a ? C ? 0.75 : e ? 0.5 : 0 : -1;
                        b = (b.clientY + B - s) / c.height();
                        (I == 1 || b <= I && b >= -0.2) && e ? (a = 1 - t.width(), l = s - t.height() / 2, v = d.move.TYPE_PREV) : (C == 0 || b >= C && b <= 1.2) && a ? (a = 1 - t.width(), l = l == null || w.isParent && w.open ? s + c.height() - t.height() / 2 : l.offset().top - t.height() / 2, v = d.move.TYPE_NEXT) : (a = 5 - t.width(), l = s, v = d.move.TYPE_INNER);
                        t.css({display: "block", top: l + "px", left: j + a + "px"});
                        c.addClass(d.node.TMPTARGET_NODE +
                            "_" + v);
                        if (P != u || Q != v)J = (new Date).getTime();
                        if (w && w.isParent && v == d.move.TYPE_INNER && (b = !0, window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId !== w.tId ? (clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId = null) : window.zTreeMoveTimer && window.zTreeMoveTargetNodeTId === w.tId && (b = !1), b))window.zTreeMoveTimer = setTimeout(function () {
                            v == d.move.TYPE_INNER && w && w.isParent && !w.open && (new Date).getTime() - J > i.edit.drag.autoOpenTime && h.apply(i.callback.beforeDragOpen, [i.treeId, w], !0) && (f.switchNode(i,
                                w), i.edit.drag.autoExpandTrigger && i.treeObj.trigger(d.event.EXPAND, [i.treeId, w]))
                        }, i.edit.drag.autoOpenTime + 50), window.zTreeMoveTargetNodeTId = w.tId
                    }
                } else if (v = d.move.TYPE_INNER, r && h.apply(i.edit.drag.inner, [i.treeId, m, null], !!i.edit.drag.inner) ? r.addClass(d.node.TMPTARGET_TREE) : r = null, t.css({display: "none"}), window.zTreeMoveTimer)clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId = null;
                P = u;
                Q = v
            }
            return!1
        }

        function q(b) {
            if (window.zTreeMoveTimer)clearTimeout(window.zTreeMoveTimer), window.zTreeMoveTargetNodeTId =
                null;
            Q = P = null;
            x.unbind("mousemove", c);
            x.unbind("mouseup", q);
            x.unbind("selectstart", e);
            k("body").css("cursor", "auto");
            r && (r.removeClass(d.node.TMPTARGET_TREE), u && k("#" + u + d.id.A, r).removeClass(d.node.TMPTARGET_NODE + "_" + d.move.TYPE_PREV).removeClass(d.node.TMPTARGET_NODE + "_" + F.move.TYPE_NEXT).removeClass(d.node.TMPTARGET_NODE + "_" + F.move.TYPE_INNER));
            h.showIfameMask(g, !1);
            z.showHoverDom = !0;
            if (z.dragFlag != 0) {
                z.dragFlag = 0;
                var a, l, j;
                for (a = 0, l = m.length; a < l; a++)j = m[a], j.isParent && z.dragNodeShowBefore[j.tId] && !j.open && (f.expandCollapseNode(g, j, !j.open), delete z.dragNodeShowBefore[j.tId]);
                y && y.remove();
                t && t.remove();
                var o = b.ctrlKey && g.edit.drag.isMove && g.edit.drag.isCopy || !g.edit.drag.isMove && g.edit.drag.isCopy;
                !o && r && u && m[0].parentTId && u == m[0].parentTId && v == d.move.TYPE_INNER && (r = null);
                if (r) {
                    var n = u == null ? null : p.getNodeCache(i, u);
                    if (h.apply(g.callback.beforeDrop, [i.treeId, m, n, v, o], !0) != !1) {
                        var s = o ? h.clone(m) : m;
                        a = function () {
                            if (G) {
                                if (!o)for (var b = 0, a = m.length; b < a; b++)f.removeNode(g, m[b]);
                                if (v == d.move.TYPE_INNER)f.addNodes(i,
                                    n, s); else if (f.addNodes(i, n.getParentNode(), s), v == d.move.TYPE_PREV)for (b = 0, a = s.length; b < a; b++)f.moveNode(i, n, s[b], v, !1); else for (b = -1, a = s.length - 1; b < a; a--)f.moveNode(i, n, s[a], v, !1)
                            } else if (o && v == d.move.TYPE_INNER)f.addNodes(i, n, s); else if (o && f.addNodes(i, n.getParentNode(), s), v != d.move.TYPE_NEXT)for (b = 0, a = s.length; b < a; b++)f.moveNode(i, n, s[b], v, !1); else for (b = -1, a = s.length - 1; b < a; a--)f.moveNode(i, n, s[a], v, !1);
                            for (b = 0, a = s.length; b < a; b++)f.selectNode(i, s[b], b > 0);
                            k("#" + s[0].tId).focus().blur()
                        };
                        v == d.move.TYPE_INNER &&
                            h.canAsync(i, n) ? f.asyncNode(i, n, !1, a) : a();
                        g.treeObj.trigger(d.event.DROP, [b, i.treeId, s, n, v, o])
                    }
                } else {
                    for (a = 0, l = m.length; a < l; a++)f.selectNode(i, m[a], a > 0);
                    g.treeObj.trigger(d.event.DROP, [b, g.treeId, m, null, null, null])
                }
            }
        }

        function e() {
            return!1
        }

        var l, j, g = p.getSetting(b.data.treeId), z = p.getRoot(g);
        if (b.button == 2 || !g.edit.enable || !g.edit.drag.isCopy && !g.edit.drag.isMove)return!0;
        var o = b.target, n = p.getRoot(g).curSelectedList, m = [];
        if (p.isSelectedNode(g, a))for (l = 0, j = n.length; l < j; l++) {
            if (n[l].editNameFlag && h.eqs(o.tagName,
                "input") && o.getAttribute("treeNode" + d.id.INPUT) !== null)return!0;
            m.push(n[l]);
            if (m[0].parentTId !== n[l].parentTId) {
                m = [a];
                break
            }
        } else m = [a];
        f.editNodeBlur = !0;
        f.cancelCurEditNode(g, null, !0);
        var x = k(document), y, t, r, G = !1, i = g, D, E, P = null, Q = null, u = null, v = d.move.TYPE_INNER, K = b.clientX, L = b.clientY, J = (new Date).getTime();
        h.uCanDo(g) && x.bind("mousemove", c);
        x.bind("mouseup", q);
        x.bind("selectstart", e);
        b.preventDefault && b.preventDefault();
        return!0
    }};
    k.extend(!0, k.fn.zTree.consts, F);
    k.extend(!0, k.fn.zTree._z, {tools: {getAbs: function (b) {
        b =
            b.getBoundingClientRect();
        return[b.left, b.top]
    }, inputFocus: function (b) {
        b.get(0) && (b.focus(), h.setCursorPosition(b.get(0), b.val().length))
    }, inputSelect: function (b) {
        b.get(0) && (b.focus(), b.select())
    }, setCursorPosition: function (b, a) {
        if (b.setSelectionRange)b.focus(), b.setSelectionRange(a, a); else if (b.createTextRange) {
            var c = b.createTextRange();
            c.collapse(!0);
            c.moveEnd("character", a);
            c.moveStart("character", a);
            c.select()
        }
    }, showIfameMask: function (b, a) {
        for (var c = p.getRoot(b); c.dragMaskList.length > 0;)c.dragMaskList[0].remove(),
            c.dragMaskList.shift();
        if (a)for (var d = k("iframe"), e = 0, f = d.length; e < f; e++) {
            var j = d.get(e), g = h.getAbs(j), j = k("<div id='zTreeMask_" + e + "' class='zTreeMask' style='top:" + g[1] + "px; left:" + g[0] + "px; width:" + j.offsetWidth + "px; height:" + j.offsetHeight + "px;'></div>");
            j.appendTo("body");
            c.dragMaskList.push(j)
        }
    }}, view: {addEditBtn: function (b, a) {
        if (!(a.editNameFlag || k("#" + a.tId + d.id.EDIT).length > 0) && h.apply(b.edit.showRenameBtn, [b.treeId, a], b.edit.showRenameBtn)) {
            var c = k("#" + a.tId + d.id.A), q = "<span class='button edit' id='" +
                a.tId + d.id.EDIT + "' title='" + h.apply(b.edit.renameTitle, [b.treeId, a], b.edit.renameTitle) + "' treeNode" + d.id.EDIT + " style='display:none;'></span>";
            c.append(q);
            k("#" + a.tId + d.id.EDIT).bind("click",function () {
                if (!h.uCanDo(b) || h.apply(b.callback.beforeEditName, [b.treeId, a], !0) == !1)return!1;
                f.editNode(b, a);
                return!1
            }).show()
        }
    }, addRemoveBtn: function (b, a) {
        if (!(a.editNameFlag || k("#" + a.tId + d.id.REMOVE).length > 0) && h.apply(b.edit.showRemoveBtn, [b.treeId, a], b.edit.showRemoveBtn)) {
            var c = k("#" + a.tId + d.id.A), q = "<span class='button remove' id='" +
                a.tId + d.id.REMOVE + "' title='" + h.apply(b.edit.removeTitle, [b.treeId, a], b.edit.removeTitle) + "' treeNode" + d.id.REMOVE + " style='display:none;'></span>";
            c.append(q);
            k("#" + a.tId + d.id.REMOVE).bind("click",function () {
                if (!h.uCanDo(b) || h.apply(b.callback.beforeRemove, [b.treeId, a], !0) == !1)return!1;
                f.removeNode(b, a);
                b.treeObj.trigger(d.event.REMOVE, [b.treeId, a]);
                return!1
            }).bind("mousedown",function () {
                return!0
            }).show()
        }
    }, addHoverDom: function (b, a) {
        if (p.getRoot(b).showHoverDom)a.isHover = !0, b.edit.enable && (f.addEditBtn(b,
            a), f.addRemoveBtn(b, a)), h.apply(b.view.addHoverDom, [b.treeId, a])
    }, cancelCurEditNode: function (b, a) {
        var c = p.getRoot(b), q = b.data.key.name, e = c.curEditNode;
        if (e) {
            var l = c.curEditInput, j = a ? a : l.val();
            if (!a && h.apply(b.callback.beforeRename, [b.treeId, e, j], !0) === !1)return e.editNameFlag = !0, !1; else e[q] = j ? j : l.val(), a || b.treeObj.trigger(d.event.RENAME, [b.treeId, e]);
            k("#" + e.tId + d.id.A).removeClass(d.node.CURSELECTED_EDIT);
            l.unbind();
            f.setNodeName(b, e);
            e.editNameFlag = !1;
            c.curEditNode = null;
            c.curEditInput = null;
            f.selectNode(b,
                e, !1)
        }
        return c.noSelection = !0
    }, editNode: function (b, a) {
        var c = p.getRoot(b);
        f.editNodeBlur = !1;
        if (p.isSelectedNode(b, a) && c.curEditNode == a && a.editNameFlag)setTimeout(function () {
            h.inputFocus(c.curEditInput)
        }, 0); else {
            var q = b.data.key.name;
            a.editNameFlag = !0;
            f.removeTreeDom(b, a);
            f.cancelCurEditNode(b);
            f.selectNode(b, a, !1);
            k("#" + a.tId + d.id.SPAN).html("<input type=text class='rename' id='" + a.tId + d.id.INPUT + "' treeNode" + d.id.INPUT + " >");
            var e = k("#" + a.tId + d.id.INPUT);
            e.attr("value", a[q]);
            b.edit.editNameSelectAll ?
                h.inputSelect(e) : h.inputFocus(e);
            e.bind("blur",function () {
                f.editNodeBlur || f.cancelCurEditNode(b)
            }).bind("keydown",function (c) {
                c.keyCode == "13" ? (f.editNodeBlur = !0, f.cancelCurEditNode(b, null, !0)) : c.keyCode == "27" && f.cancelCurEditNode(b, a[q])
            }).bind("click",function () {
                return!1
            }).bind("dblclick", function () {
                return!1
            });
            k("#" + a.tId + d.id.A).addClass(d.node.CURSELECTED_EDIT);
            c.curEditInput = e;
            c.noSelection = !1;
            c.curEditNode = a
        }
    }, moveNode: function (b, a, c, q, e, l) {
        var j = p.getRoot(b), g = b.data.key.children;
        if (a != c && (!b.data.keep.leaf || !a || a.isParent || q != d.move.TYPE_INNER)) {
            var h = c.parentTId ? c.getParentNode() : j, o = a === null || a == j;
            o && a === null && (a = j);
            if (o)q = d.move.TYPE_INNER;
            j = a.parentTId ? a.getParentNode() : j;
            if (q != d.move.TYPE_PREV && q != d.move.TYPE_NEXT)q = d.move.TYPE_INNER;
            if (q == d.move.TYPE_INNER)if (o)c.parentTId = null; else {
                if (!a.isParent)a.isParent = !0, a.open = !!a.open, f.setNodeLineIcos(b, a);
                c.parentTId = a.tId
            }
            var n;
            o ? n = o = b.treeObj : (!l && q == d.move.TYPE_INNER ? f.expandCollapseNode(b, a, !0, !1) : l || f.expandCollapseNode(b, a.getParentNode(), !0, !1),
                o = k("#" + a.tId), n = k("#" + a.tId + d.id.UL), o.get(0) && !n.get(0) && (n = [], f.makeUlHtml(b, a, n, ""), o.append(n.join(""))), n = k("#" + a.tId + d.id.UL));
            var m = k("#" + c.tId);
            m.get(0) ? o.get(0) || m.remove() : m = f.appendNodes(b, c.level, [c], null, !1, !0).join("");
            n.get(0) && q == d.move.TYPE_INNER ? n.append(m) : o.get(0) && q == d.move.TYPE_PREV ? o.before(m) : o.get(0) && q == d.move.TYPE_NEXT && o.after(m);
            var x = -1, y = 0, t = null, o = null, r = c.level;
            if (c.isFirstNode) {
                if (x = 0, h[g].length > 1)t = h[g][1], t.isFirstNode = !0
            } else if (c.isLastNode)x = h[g].length - 1,
                t = h[g][x - 1], t.isLastNode = !0; else for (n = 0, m = h[g].length; n < m; n++)if (h[g][n].tId == c.tId) {
                x = n;
                break
            }
            x >= 0 && h[g].splice(x, 1);
            if (q != d.move.TYPE_INNER)for (n = 0, m = j[g].length; n < m; n++)j[g][n].tId == a.tId && (y = n);
            if (q == d.move.TYPE_INNER) {
                a[g] || (a[g] = []);
                if (a[g].length > 0)o = a[g][a[g].length - 1], o.isLastNode = !1;
                a[g].splice(a[g].length, 0, c);
                c.isLastNode = !0;
                c.isFirstNode = a[g].length == 1
            } else a.isFirstNode && q == d.move.TYPE_PREV ? (j[g].splice(y, 0, c), o = a, o.isFirstNode = !1, c.parentTId = a.parentTId, c.isFirstNode = !0, c.isLastNode = !1) : a.isLastNode && q == d.move.TYPE_NEXT ? (j[g].splice(y + 1, 0, c), o = a, o.isLastNode = !1, c.parentTId = a.parentTId, c.isFirstNode = !1, c.isLastNode = !0) : (q == d.move.TYPE_PREV ? j[g].splice(y, 0, c) : j[g].splice(y + 1, 0, c), c.parentTId = a.parentTId, c.isFirstNode = !1, c.isLastNode = !1);
            p.fixPIdKeyValue(b, c);
            p.setSonNodeLevel(b, c.getParentNode(), c);
            f.setNodeLineIcos(b, c);
            f.repairNodeLevelClass(b, c, r);
            !b.data.keep.parent && h[g].length < 1 ? (h.isParent = !1, h.open = !1, a = k("#" + h.tId + d.id.UL), q = k("#" + h.tId + d.id.SWITCH), g = k("#" + h.tId + d.id.ICON),
                f.replaceSwitchClass(h, q, d.folder.DOCU), f.replaceIcoClass(h, g, d.folder.DOCU), a.css("display", "none")) : t && f.setNodeLineIcos(b, t);
            o && f.setNodeLineIcos(b, o);
            b.check && b.check.enable && f.repairChkClass && (f.repairChkClass(b, h), f.repairParentChkClassWithSelf(b, h), h != c.parent && f.repairParentChkClassWithSelf(b, c));
            l || f.expandCollapseParentNode(b, c.getParentNode(), !0, e)
        }
    }, removeEditBtn: function (b) {
        k("#" + b.tId + d.id.EDIT).unbind().remove()
    }, removeRemoveBtn: function (b) {
        k("#" + b.tId + d.id.REMOVE).unbind().remove()
    },
        removeTreeDom: function (b, a) {
            a.isHover = !1;
            f.removeEditBtn(a);
            f.removeRemoveBtn(a);
            h.apply(b.view.removeHoverDom, [b.treeId, a])
        }, repairNodeLevelClass: function (b, a, c) {
            if (c !== a.level) {
                var b = k("#" + a.tId), f = k("#" + a.tId + d.id.A), e = k("#" + a.tId + d.id.UL), c = "level" + c, a = "level" + a.level;
                b.removeClass(c);
                b.addClass(a);
                f.removeClass(c);
                f.addClass(a);
                e.removeClass(c);
                e.addClass(a)
            }
        }}, event: {}, data: {setSonNodeLevel: function (b, a, c) {
        if (c) {
            var d = b.data.key.children;
            c.level = a ? a.level + 1 : 0;
            if (c[d])for (var a = 0, e = c[d].length; a <
                e; a++)c[d][a] && p.setSonNodeLevel(b, c, c[d][a])
        }
    }}});
    var E = k.fn.zTree, h = E._z.tools, d = E.consts, f = E._z.view, p = E._z.data;
    p.exSetting({edit: {enable: !1, editNameSelectAll: !1, showRemoveBtn: !0, showRenameBtn: !0, removeTitle: "remove", renameTitle: "rename", drag: {autoExpandTrigger: !1, isCopy: !0, isMove: !0, prev: !0, next: !0, inner: !0, minMoveSize: 5, borderMax: 10, borderMin: -5, maxShowNodeNum: 5, autoOpenTime: 500}}, view: {addHoverDom: null, removeHoverDom: null}, callback: {beforeDrag: null, beforeDragOpen: null, beforeDrop: null, beforeEditName: null,
        beforeRename: null, onDrag: null, onDrop: null, onRename: null}});
    p.addInitBind(function (b) {
        var a = b.treeObj, c = d.event;
        a.bind(c.RENAME, function (a, c, d) {
            h.apply(b.callback.onRename, [a, c, d])
        });
        a.bind(c.REMOVE, function (a, c, d) {
            h.apply(b.callback.onRemove, [a, c, d])
        });
        a.bind(c.DRAG, function (a, c, d, f) {
            h.apply(b.callback.onDrag, [c, d, f])
        });
        a.bind(c.DROP, function (a, c, d, f, g, k, o) {
            h.apply(b.callback.onDrop, [c, d, f, g, k, o])
        })
    });
    p.addInitUnBind(function (b) {
        var b = b.treeObj, a = d.event;
        b.unbind(a.RENAME);
        b.unbind(a.REMOVE);
        b.unbind(a.DRAG);
        b.unbind(a.DROP)
    });
    p.addInitCache(function () {
    });
    p.addInitNode(function (b, a, c) {
        if (c)c.isHover = !1, c.editNameFlag = !1
    });
    p.addInitProxy(function (b) {
        var a = b.target, c = p.getSetting(b.data.treeId), f = b.relatedTarget, e = "", l = null, j = "", g = null, k = null;
        if (h.eqs(b.type, "mouseover")) {
            if (k = h.getMDom(c, a, [
                {tagName: "a", attrName: "treeNode" + d.id.A}
            ]))e = k.parentNode.id, j = "hoverOverNode"
        } else if (h.eqs(b.type, "mouseout"))k = h.getMDom(c, f, [
            {tagName: "a", attrName: "treeNode" + d.id.A}
        ]), k || (e = "remove", j = "hoverOutNode"); else if (h.eqs(b.type,
            "mousedown") && (k = h.getMDom(c, a, [
            {tagName: "a", attrName: "treeNode" + d.id.A}
        ])))e = k.parentNode.id, j = "mousedownNode";
        if (e.length > 0)switch (l = p.getNodeCache(c, e), j) {
            case "mousedownNode":
                g = D.onMousedownNode;
                break;
            case "hoverOverNode":
                g = D.onHoverOverNode;
                break;
            case "hoverOutNode":
                g = D.onHoverOutNode
        }
        return{stop: !1, node: l, nodeEventType: j, nodeEventCallback: g, treeEventType: "", treeEventCallback: null}
    });
    p.addInitRoot(function (b) {
        b = p.getRoot(b);
        b.curEditNode = null;
        b.curEditInput = null;
        b.curHoverNode = null;
        b.dragFlag =
            0;
        b.dragNodeShowBefore = [];
        b.dragMaskList = [];
        b.showHoverDom = !0
    });
    p.addZTreeTools(function (b, a) {
        a.cancelEditName = function (a) {
            var d = p.getRoot(b), e = b.data.key.name, h = d.curEditNode;
            d.curEditNode && f.cancelCurEditNode(b, a ? a : h[e])
        };
        a.copyNode = function (a, k, e, l) {
            if (!k)return null;
            if (a && !a.isParent && b.data.keep.leaf && e === d.move.TYPE_INNER)return null;
            var j = h.clone(k);
            if (!a)a = null, e = d.move.TYPE_INNER;
            e == d.move.TYPE_INNER ? (k = function () {
                f.addNodes(b, a, [j], l)
            }, h.canAsync(b, a) ? f.asyncNode(b, a, l, k) : k()) : (f.addNodes(b,
                a.parentNode, [j], l), f.moveNode(b, a, j, e, !1, l));
            return j
        };
        a.editName = function (a) {
            a && a.tId && a === p.getNodeCache(b, a.tId) && (a.parentTId && f.expandCollapseParentNode(b, a.getParentNode(), !0), f.editNode(b, a))
        };
        a.moveNode = function (a, q, e, l) {
            function j() {
                f.moveNode(b, a, q, e, !1, l)
            }

            if (!q)return q;
            if (a && !a.isParent && b.data.keep.leaf && e === d.move.TYPE_INNER)return null; else if (a && (q.parentTId == a.tId && e == d.move.TYPE_INNER || k("#" + q.tId).find("#" + a.tId).length > 0))return null; else a || (a = null);
            h.canAsync(b, a) ? f.asyncNode(b,
                a, l, j) : j();
            return q
        };
        a.setEditable = function (a) {
            b.edit.enable = a;
            return this.refresh()
        }
    });
    var K = f.cancelPreSelectedNode;
    f.cancelPreSelectedNode = function (b, a) {
        for (var c = p.getRoot(b).curSelectedList, d = 0, e = c.length; d < e; d++)if (!a || a === c[d])if (f.removeTreeDom(b, c[d]), a)break;
        K && K.apply(f, arguments)
    };
    var L = f.createNodes;
    f.createNodes = function (b, a, c, d) {
        L && L.apply(f, arguments);
        c && f.repairParentChkClassWithSelf && f.repairParentChkClassWithSelf(b, d)
    };
    f.makeNodeUrl = function (b, a) {
        return a.url && !b.edit.enable ? a.url :
            null
    };
    var J = f.removeNode;
    f.removeNode = function (b, a) {
        var c = p.getRoot(b);
        if (c.curEditNode === a)c.curEditNode = null;
        J && J.apply(f, arguments)
    };
    var M = f.selectNode;
    f.selectNode = function (b, a, c) {
        var d = p.getRoot(b);
        if (p.isSelectedNode(b, a) && d.curEditNode == a && a.editNameFlag)return!1;
        M && M.apply(f, arguments);
        f.addHoverDom(b, a);
        return!0
    };
    var N = h.uCanDo;
    h.uCanDo = function (b, a) {
        var c = p.getRoot(b);
        return a && (h.eqs(a.type, "mouseover") || h.eqs(a.type, "mouseout") || h.eqs(a.type, "mousedown") || h.eqs(a.type, "mouseup")) ? !0 : !c.curEditNode &&
            (N ? N.apply(f, arguments) : !0)
    }
})(jQuery);

